<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>String.prototype.split() - Tag - 밤에 하는 개발</title>
        <link>http://qweqwe9ab.github.io/tags/string.prototype.split/</link>
        <description>String.prototype.split() - Tag - 밤에 하는 개발</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>qweqwe9ab@gmail.com (밤개발)</managingEditor>
            <webMaster>qweqwe9ab@gmail.com (밤개발)</webMaster><lastBuildDate>Thu, 08 Jul 2021 00:55:05 &#43;0900</lastBuildDate><atom:link href="http://qweqwe9ab.github.io/tags/string.prototype.split/" rel="self" type="application/rss+xml" /><item>
    <title>[LeetCode] 49. Group Anagrams</title>
    <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-49/</link>
    <pubDate>Thu, 08 Jul 2021 00:55:05 &#43;0900</pubDate>
    <author>Author</author>
    <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-49/</guid>
    <description><![CDATA[#49. Group Anagrams
문제 단어의 배열을 받아서, 단어를 구성하는 알파벳의 순서가 다르더라고 같은 알파벳 들로 구성된 단어들을 묶어서 배열로 반환하는 문제입니다.
 EX) &lsquo;eat&rsquo;, &lsquo;ate&rsquo;, &lsquo;tea&rsquo;는 같이 묶여서 반환 됩니다.
 설명 우선, 단어에 문자 순서가 다른 모든 단어를 찾고 저장하기 위해서 기준으로 알파벳 순으로 정렬된 단어를 만든다. 예를 들어 eat, ate, tae에서는 알파벳 순서로 aet가 키가 되는 것이다. 이 키를 만들기 위해서 split()으로 단어를 쪼개고, sort() 를 사용해서 알파벳의 순서를 정렬하고, join() 을 이용해서 배열을 다시 단어로 만듭니다.]]></description>
</item></channel>
</rss>
