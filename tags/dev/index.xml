<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dev on Javascript Docs</title>
    <link>http://qweqwe9ab.github.io/tags/dev/</link>
    <description>Recent content in dev on Javascript Docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>qweqwe9ab@gmail.com (밤개발)</managingEditor>
    <webMaster>qweqwe9ab@gmail.com (밤개발)</webMaster>
    <lastBuildDate>Sun, 20 Jan 2019 18:29:32 +0000</lastBuildDate><atom:link href="http://qweqwe9ab.github.io/tags/dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[javascript] 하노이 탑 (Hanoi Tower)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190120-Hanoi/</link>
      <pubDate>Sun, 20 Jan 2019 18:29:32 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190120-Hanoi/</guid>
      <description>하노이 탑 하노이 탑은 다음과 같은 조건을 가지고 있다.
한번에 하나의 원판만 이동 맨위에 있는 원판만 이동 가능 작은 원판 위에 큰 원판을 올리는 것은 불가능 중간의 막대는 임시적으로 이용 가능 n-1개를 A에서 B로 이동하고, n개를 A에서 C로 이동한다. 그리고 n-1개를 B에서 C로 이동한다.
1 2 3 4 5 6 7 8 9 10 let hanoi = (n, from, temp, to) =&amp;gt; { if(n===1) console.log(`${n}을 ${from}에서 ${to}로 이동`); else { hanoi(n-1, from, to, temp); console.</description>
    </item>
    
    <item>
      <title>[javascript] 피보나치 (Fibonacci)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190120-Fibonacci/</link>
      <pubDate>Sun, 20 Jan 2019 17:53:44 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190120-Fibonacci/</guid>
      <description>피보나치 수열 0, 1, 1, 2, 3, 5, 8, 13, 21.... 피보나치는 0번째는 0, 첫 번째는 1 그 이후로는 이전 두개의 수를 더한 값을 갖는 수열이다.
F(0) = 0, F(1) = 1, F(n) = F(n-2) + F(n-1)
1 2 3 4 5 6 7 8 9 10 11 let fib = (num) =&amp;gt; { if(num &amp;lt;= 1) return num; return fib(num-1) + fib(num-2); } console.log(fib(1)) console.log(fib(2)) console.log(fib(3)) console.log(fib(4)) console.log(fib(5)) console.</description>
    </item>
    
    <item>
      <title>동기와 비동기</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190119-Sync-VS-Async/</link>
      <pubDate>Sat, 19 Jan 2019 17:42:36 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190119-Sync-VS-Async/</guid>
      <description>설명 동기 여러작업을 진행 할때 하나의 작업이 끝날때 까지 기다렸다가 다음 작업을 진행하는 것.
비동기 여러작업을 진행 할때 하나의 작업을 실행하고 다음 작업으로 넘어간다. 이전에 실행한 작업은 작업이 끝나고 callback을 넘긴다.
비유 간단하게 설명하면 동기는 카페에서 손님에게 주문을 받고 커피를 만들어서 전달하고 다음 손님으로 넘어가는 것 이고 비동기는 카페에서 손님에게 주문을 받고 진동벨을 준 다음 다음 손님의 주문으로 넘어가고, 손님의 커피가 제조가 완료되면 진동벨(callback)을 울려 해당 손님에게 전달한다.
코드 동기 코드</description>
    </item>
    
    <item>
      <title>프로세스(Process) vs 쓰레드(Thread)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190119-Process-VS-Thread/</link>
      <pubDate>Sat, 19 Jan 2019 17:09:10 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190119-Process-VS-Thread/</guid>
      <description>프로세스 프로세스는 실행중인 프로그램이다. 디스크로에서 메모리로 적재되어 CPU의 할당을 받을 수 있다. 쓰레드 프로세스의 실행단위 한 프로세스 내에서 동작되는 여러 실행으로 프로세스내의 주소공간이나 자원을 공유한다. 멀티 쓰레드 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 쓰레드 간의 공유된 자원을 사용해 쓰레드간의 통신이 간단하고 빠르다 멀티 쓰레드 문제점 자원을 공유하기 때문에 신경을 써야한다. 동기화 작업으로 인해 성능이 저하될 수 있다. 요약 프로세스는 운영체제로 부터 자원을 할당받는 자원단위(실행중인 프로그램) 쓰레드는 프로세스가 할당 받은 자원을 이용하는 실행 단위()</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 스택으로 큐 구현 javascript</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Queue-Using-Stacks/</link>
      <pubDate>Fri, 18 Jan 2019 15:46:22 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Queue-Using-Stacks/</guid>
      <description>오늘은 스택으로 큐를 구현하는 문제를 살펴보겠습니다. 스택은 LIFO - Last In First Out 방식이다. 간단하게 설명하면 책상 위에 책을 하나씩 쌓아두고 위에서부터 하나씩 집어서 읽는 것이다.
나중에 쌓은(제일 위에 있는) 책을 먼저 집어서 읽는 방식 큐는 FIFO - First In First Out 방식이다. 간단하게 설명하면 카페에서 한 줄로 서서 주문을 하는 것이다.
제일 먼저 온 사람이 먼저 계산하는 방식 스택과 큐에 대한 설명과 코드는 이 블로그의 글을 참조하고, 오늘은 스택으로 큐를 구현해 보겠습니다.</description>
    </item>
    
    <item>
      <title>[Codewars] 주사위 게임 &#34;Greed is Good&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Greed-is-Good/</link>
      <pubDate>Fri, 18 Jan 2019 15:35:22 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Greed-is-Good/</guid>
      <description>설명 문제 주사위(1-6)를 굴려서 나온 수에 따른 점수를 매겨라.
1 2 3 4 5 6 7 8 Three 1&amp;#39;s =&amp;gt; 1000 points Three 6&amp;#39;s =&amp;gt; 600 points Three 5&amp;#39;s =&amp;gt; 500 points Three 4&amp;#39;s =&amp;gt; 400 points Three 3&amp;#39;s =&amp;gt; 300 points Three 2&amp;#39;s =&amp;gt; 200 points One 1 =&amp;gt; 100 points One 5 =&amp;gt; 50 point 1 2 3 4 5 Throw Score --------- ------------------ 5 1 3 4 1 50 + 2 * 100 = 250 1 1 1 3 1 1000 + 100 = 1100 2 4 4 5 4 400 + 50 = 450 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function score( dice ) { let scores = {}; let returnValue = 0; for(let i in dice) { if(scores[dice[i]]) { scores[dice[i]]++; }else { scores[dice[i]] = 1; } } for(let i in scores) { let s = scores[i]; if(i == 1 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 1000; s -=3;} if(i == 2 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 200; s -=3;} if(i == 3 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 300; s -=3;} if(i == 4 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 400; s -=3;} if(i == 5 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 500; s -=3;} if(i == 6 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 600; s -=3;} if(i == 1) returnValue += s * 100; if(i == 5) returnValue += s * 50; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 function score( dice ) { var dc = [0,0,0,0,0,0]; var tdr = [1000,200,300,400,500,600]; var sdr = [100,0,0,0,50,0]; dice.</description>
    </item>
    
    <item>
      <title>[Codewars] 다이아몬드 모양 출력 &#34;Codewars_Give_me_a_Diamond&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Give-me-a-Diamond/</link>
      <pubDate>Fri, 18 Jan 2019 04:57:35 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Give-me-a-Diamond/</guid>
      <description>설명 문제 n을 입력받아서 다이아몬드 모양을 출력하는 문제
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function diamond(n){ if(n &amp;lt; 0 || n%2 ==0) return null; let returnValue = &amp;#39;&amp;#39;; for(let i = 1;i&amp;lt;=n;i+=2) { for(let j=0;j&amp;lt;(n-i)/2;j++) returnValue += &amp;#39; &amp;#39;; for(let j=0;j&amp;lt;i;j++)returnValue += &amp;#39;*&amp;#39;; returnValue +=&amp;#39;\n&amp;#39;; } for(let i = n-2; i&amp;gt;0; i-=2) { for(let j=0;j&amp;lt;(n-i)/2;j++) returnValue += &amp;#39; &amp;#39;; for(let j=0;j&amp;lt;i;j++)returnValue += &amp;#39;*&amp;#39;; returnValue +=&amp;#39;\n&amp;#39;; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 10 11 12 function diamond(n){ if( n%2==0 || n&amp;lt;1 ) return null var x=0, add, diam = line(x,n); while( (x+=2) &amp;lt; n ){ add = line(x/2,n-x); diam = add+diam+add; } return diam; } function repeat(str,x){return Array(x+1).</description>
    </item>
    
    <item>
      <title>[Codewars] 후위표기법 문제 &#34;Reverse polish notation calculator&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Reverse-Polish-Notation-Calculator/</link>
      <pubDate>Fri, 18 Jan 2019 04:24:18 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Reverse-Polish-Notation-Calculator/</guid>
      <description>우리가 알고있는 수식은 5 + ((1 + 2) * 4) - 3 같은 식이다. 하지만 후위표기법에서는 5 1 2 + 4 * + 3 -이런식으로 표현한다.
문제 후위표기법으로 제공되는 식을 풀어 답을 리턴하시오.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function calc(expr) { let exp = expr.</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 연결리스트(linked list)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Linked-List/</link>
      <pubDate>Thu, 17 Jan 2019 17:40:16 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Linked-List/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const linkedListNode = class LinkedListNode { constructor(value, next = null) { this.</description>
    </item>
    
    <item>
      <title>REST API</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Rest-API/</link>
      <pubDate>Thu, 17 Jan 2019 17:12:02 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Rest-API/</guid>
      <description>REST API REST (Representational State Transfer) web의 장점을 최대한 활용할 수 있는 아키텍쳐 HTTP 메서드 메서드 의미 멱등성 POST Create x GET Select O PUT Update O DELETE Delete O 멱등성 : 연산을 여러번해도 달라지지 않는것. REST는 상태 없이 API를 수행한다 그래서 여러 API를 호출하다 실패시 복구해야 하는데 멱등성 메서드는 복구가 필요없다. REST는 리소스 지향으로 모든 것은 명사로 표현한다. 각 세부 리소스에는 ID를 추가한다. REST API의 특성 유니폼 인터페이스 : 표준만 따르면 어떤 기술이라도 사용가능 무상태성 / 스테이트리스 : 서버는 상태를 저장하지 않으므로 각 API 서버는 들어오는 요청만 수행, 구현이 단순 캐슁가능 : HTTP에서 제공하는 캐슁 가능 자체 표현구조 : REST API만 보고 쉽게 이해할 수 있다.</description>
    </item>
    
    <item>
      <title>http와 https</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-http-vs-https/</link>
      <pubDate>Thu, 17 Jan 2019 16:15:54 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-http-vs-https/</guid>
      <description> Related Posts http (Hyper Text Transfer Protocol) Client와 Server가 메세지를 주고 받는 통신 규약 http://로 시작 메세지를 암호화 하지 않음 https (Hyper Text Transfer Protocol Secure Socket Layer) Client와 Server가 메세지를 주고 받는 통신 규약 https://로 시작 메세지를 암호화함 공개키, 개인키 암호화 SSL 인증서 구입 비용과 갱신 비용이 비싸다 암호화로 속도가 느리다 Related Posts </description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 큐(Queue)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Queue/</link>
      <pubDate>Wed, 16 Jan 2019 17:40:01 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Queue/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function createQueue() { const queue = []; return { enqueue(item) { queue.unshift(item); }, dequeue() { return queue.pop(); }, peek() { return queue[queue.length -1]; }, get length() { return queue.length; }, isEmpty() { return queue.length === 0; } } } const q = createQueue(); q.</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 스택(Stack)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Stack/</link>
      <pubDate>Wed, 16 Jan 2019 17:39:50 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Stack/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function createStack() { const stack = []; return { push(item) { stack.push(item); }, pop() { return stack.pop(); }, peek() { return stack[stack.length - 1]; }, get length() { return stack.length; }, isEmpty() { return stack.length === 0; } } } const s = createStack(); s.</description>
    </item>
    
    <item>
      <title>[jstips] 중첩된 조건문 개선 if, switch</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190114-improve-nested-conditionals/</link>
      <pubDate>Mon, 14 Jan 2019 18:04:48 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190114-improve-nested-conditionals/</guid>
      <description>중첩된 조건문 개선 jstips에서 javascript를 사용할 때 중첩된 if문을 조금 더 깔끔하고 효율적으로 만들 수 있을지에 대해서 읽었습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (color) { if (color === &amp;#39;black&amp;#39;) { printBlackBackground(); } else if (color === &amp;#39;red&amp;#39;) { printRedBackground(); } else if (color === &amp;#39;blue&amp;#39;) { printBlueBackground(); } else if (color === &amp;#39;green&amp;#39;) { printGreenBackground(); } else { printYellowBackground(); } } 우선 중첩된 if문을 개선하는 방법 중에 하나는 switch문을 사용하는 것입니다.</description>
    </item>
    
    <item>
      <title>[jstips] 배열에 요소 추가하기 push(),concat(),unshift()</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190114-insert-item-inside-an-array/</link>
      <pubDate>Mon, 14 Jan 2019 18:01:39 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190114-insert-item-inside-an-array/</guid>
      <description>오늘은 jstips에서 첫 번째 팁인 배열에 요소 추가하는 방법을 공부해보겠습니다.
저도 개발을 하다 보면 배열에 요소를 추가하는 작업을 많이 하게 되는데, push()를 사용해서 배열의 끝에 요소를 넣고, unshift를 사용해서 배열의 시작 부분에 요소를 넣고, splice를 사용해서 배열의 중간에 요소를 넣는 것은 알고 그렇게 작업을 했었습니다. 근데 jstips에서 글을 읽으면서 속도와 성능을 생각하면서 작업을 하는 것도 필요할 것 같다는 생각이 들었습니다.
귀찮은 분들을 위해 맨 아래에 결론을 적어놨습니다!
배열의 끝부분에 추가 배열의 끝에 요소를 추가하는 방법 중 제일 쉬운 방법은 push()를 사용하는 것인데, 다른 방법들도 있다.</description>
    </item>
    
  </channel>
</rss>
