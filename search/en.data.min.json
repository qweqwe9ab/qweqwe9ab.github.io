[{"id":0,"href":"/posts/etc/2022/","title":"2022년 계획","parent":"Posts","content":"인생의 전환점을 맞았던 21년은 새로운 인생을 위해서 조금 쉬어가는 시간을 보냈어\n22년은 전환점을 지나서 새로운 시작이라고 생각하고, 새로운 계획을 세워보려해.\n22년의 키워드는 지식 저장이야.\n개발자는 공부를 많이 해야하는 직업이고, 새로운 지식을 늘려야 하는 직업이야\n근데 나는 아직 공부와 지식을 저장하는 방법을 모른다고 생각해\n그래서 22년도에는 공부하는 방법과 지식을 저장하는 방법에 대해서 생각하고, 노력하는 시간으로 정했어\n공부와 지식을 저장하는 방법을 그냥 지식 저장법이라고 이야기 할게\n우선 지금 생각하는 지식을 저장하는 방법은 블로그에 저장하는 방법과 메모장에 저장하는 거야\n그리고 개인 프로젝트를 진행하면서 프로젝트 안에 저장하는 방법이야\n간단하게 트위터로 짧은 생각과 지식을 기록하고, 그 짧은 지식을 모아서 메모장에 저장한 후에\n정리해서 블로그에 기록할거야\n그 기록한 지식을을 모아서 내 개인 프로젝트에 적용할거고\n22년 후기에는 기록된 지식들을 한번 이야기하는 시간을 가질거야\n"},{"id":1,"href":"/categories/","title":"Categories","parent":"Javascript Docs","content":""},{"id":2,"href":"/categories/Dev/","title":"Dev","parent":"Categories","content":""},{"id":3,"href":"/tags/ETC/","title":"ETC","parent":"Tags","content":""},{"id":4,"href":"/categories/ETC/","title":"ETC","parent":"Categories","content":""},{"id":5,"href":"/categories/Javascrip/","title":"Javascrip","parent":"Categories","content":""},{"id":6,"href":"/tags/Javascript/","title":"Javascript","parent":"Tags","content":""},{"id":7,"href":"/","title":"Javascript Docs","parent":"","content":""},{"id":8,"href":"/posts/","title":"Posts","parent":"Javascript Docs","content":""},{"id":9,"href":"/tags/","title":"Tags","parent":"Javascript Docs","content":""},{"id":10,"href":"/posts/etc/2021/","title":"2021 하반기 계획.","parent":"Posts","content":"안녕하세요 밤개발입니다.\n아무도 들어오지 않는 블로그지만, 현재 제 상황을 제가 파악해야된다는 생각이 들어서 글을 적어봅니다.\n현재 퇴직 후 이직 준비중인데, 아직 부족한게 많다고 느껴지네요\n이제 경력이 주니어에서 시니어로 넘어가는 시점이기는 한데, 인터넷상의 다른 개발자 분들의 글과 이야기를 들어보면 한없이 작아집니다.\n물론 제가 다른 분들에 비해 뛰어난 부분도 있다고 생각합니다. 하지만, 개발적인 기술적인 스킬이 아직 부족합니다.\n"},{"id":11,"href":"/categories/Javascript/","title":"Javascript","parent":"Categories","content":""},{"id":12,"href":"/posts/js/jsonSort/","title":"Javascript JSON Value를 기준으로 정렬하기","parent":"Posts","content":" JSON의 정렬 만약 유저의 이름을 key로 점수를 value로 JSON에 저장했다고 하고\n1 2 3 4 5 const point = { \u0026#34;Jang\u0026#34;: 100, \u0026#34;Kim\u0026#34;: 20, \u0026#34;Lee\u0026#34;: 150 }; 유저를 점수순으로 리스트를 뽑아야된다면 아래와 같은 sort 함수를 만들어서 리스트를 생성한다.\n1 2 3 4 5 6 7 const sort = (ob) =\u0026gt; { const arr = []; for(let i in ob) { arr.push([i, ob[i]]); } return arr.sort((a, b) =\u0026gt; a[1] - b[1]); } sort 함수는 매개변수로 들어온 object를 for문으로 돌면서 새로운 배열에 key와 value로 저장하고 arr.push([key, value]) 함수의 끝에서 반환 하기전에 arr.sort()를 사용해서 value를 기준으로 정렬한다.\n물론 처음부터 배열에 유저이름과 점수를 저장하면 이러한 sort함수를 생성할 필요가 없지만, JSON의 쉬운 접근 때문에 이렇게 저장하는 경우가 있어서 설명해봤다.\n"},{"id":13,"href":"/tags/JSON/","title":"JSON","parent":"Tags","content":""},{"id":14,"href":"/categories/JSON/","title":"JSON","parent":"Categories","content":""},{"id":15,"href":"/posts/leetcode/20200708-leetcode-121/","title":"[LeetCode] 121. Best Time to Buy and Sell Stock [Easy]","parent":"Posts","content":"#121. Best Time to Buy and Sell Stock\n문제 주어진 배열은 일별 주식의 가격입니다. 배열의 인덱스는 날, 값은 가격입니다.\n이 배열을 가지고 매매를 해서 최대의 수익을 반환하는 문제입니다. 설명 최대 수익을 저장하는 maxProfit와 최소 금액을 저장하는 min변수를 사용해서 최대 수익을 구하고, 그 값을 반환한다.\n답 1 2 3 4 5 6 7 8 9 10 var maxProfit = function(prices) { let min = Number.MAX_SAFE_INTEGER; let maxProfit = 0; for (let i = 0; i \u0026lt; prices.length; i++) { const price = prices[i]; min = Math.min(min, price); maxProfit = Math.max(maxProfit, price - min); } return maxProfit; }; LeetCode You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\n1 2 3 4 Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:\n1 2 3 Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints:\n1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 "},{"id":16,"href":"/tags/LeetCode/","title":"LeetCode","parent":"Tags","content":""},{"id":17,"href":"/categories/LeetCode/","title":"LeetCode","parent":"Categories","content":""},{"id":18,"href":"/posts/leetcode/20200708-leetcode-238/","title":"[LeetCode] 238. Product of Array Except Self","parent":"Posts","content":"#238. Product of Array Except Self\n문제 숫자 배열 nums를 받아서 각 요소가 본인을 제외한 다른 요소 들의 곱으로 배열을 만들어 반환하는 문제이다.\nEX) A,B,C,D를 숫자라고 생각하면 [A, B, C, D]의 결과는 [BCD, ACD, ABD, ABC]이다.\n제약조건: O(n)\n설명 우선 for문을 중복으로 돌면 해결될 것 같지만, O(n)으로 만들어야 되기 때문에 다른 방법을 생각해보자.\n위에 문제에 설명 한 것 처럼 [A, B, C, D]가 주어지면 본인의 요소를 제외한 [BCD, ACD, ABD, ABC]를 반환해야 되는데. 중복 for문이 아닌 두개의 for문으로도 해결 할 수있다.\n변수 선언 변수는 왼쪽에서 부터 도는 for문을 위한 left 오른쪽에서 부터 도는 for문을 위한 right 최종 결과를 저장하기 위한 result를 선언한다.\n왼쪽에서 부터 도는 for문 배열의 왼쪽부터 돌면서 첫 요소는 1을 저장하고, 그 다음 요소 부터는 이전 요소의 값을 곱해준다. [1, A, AB, ABC]\n오른쪽에서 부터 도는 for문 배열의 오른쪽 부터 돌면서 [BCD, CD, D, 1] 맨 오른쪽 요소는 1을 저장하고, 그 다음 요소부터는 이전 요소의 값을 곱해준다. for문을 돌면서 left와 right를 사용해서 반환할 값을 생성한다.\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var productExceptSelf = function(nums) { const result = []; const left = []; const right = []; for (let i = 0; i \u0026lt; nums.length; i++) { if (i === 0) left[i] = 1; else left[i] = nums[i-1] * left[i-1]; } for (let i = nums.length -1; i \u0026gt;= 0; i--) { if (i === (nums.length-1)) right[i] = 1; else right[i] = nums[i+1] * right[i+1]; result[i] = right[i] * left[i]; } return result; }; LeetCode Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\n1 2 Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2:\n1 2 Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 105 -30 \u0026lt;= nums[i] \u0026lt;= 30 The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. "},{"id":19,"href":"/posts/leetcode/20200708-leetcode-561/","title":"[LeetCode] 561. Array Partition I","parent":"Posts","content":"#561. Array Partition I\n문제 짝수개의 정수를 갖는 정수의 배열 nums가 주어진다. 요소들을 두개씩 짝을 지어서 그 짝들의 최솟값의 합이 최대인 값을 반환한다. 설명 우선, 2개씩 짝지어진 요소의 최솟값들의 합이 최대가 되기 위해서는 배열을 정렬을 해야됩니다.\n배열을 sort() 를 사용해서 정렬하고, 작은수부터 2개씩 짝을지어 2개 중에 작은 값들을 더해서 총 합을 반환합니다.\n그냥 sort() 를 사용하면 문자순으로 정렬되기 때문에 값을 비교해서 정렬하기 위해 nums.sort((a,b) =\u0026gt; a - b); 이렇게 작업합니다. 답 1 2 3 4 5 6 7 8 var arrayPairSum = function(nums) { nums.sort((a,b) =\u0026gt; a - b); let sum = 0; for(let i = 0; i \u0026lt; nums.length; i = i+2) { sum += nums[i]; } return sum; }; LeetCode Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), \u0026hellip;, (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.\nExample 1:\n1 2 3 4 5 6 7 8 Input: nums = [1,4,3,2] Output: 4 Explanation: All possible pairings (ignoring the ordering of elements) are: 1. (1, 4), (2, 3) -\u0026gt; min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) -\u0026gt; min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) -\u0026gt; min(1, 2) + min(3, 4) = 1 + 3 = 4 So the maximum possible sum is 4. Example 2:\n1 2 3 Input: nums = [6,2,6,5,1,2] Output: 9 Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9. Constraints:\n1 \u0026lt;= n \u0026lt;= 104 nums.length == 2 * n -104 \u0026lt;= nums[i] \u0026lt;= 104 "},{"id":20,"href":"/tags/Array.prototype.sort/","title":"Array.prototype.sort()","parent":"Tags","content":""},{"id":21,"href":"/posts/leetcode/20200708-leetcode-15_/","title":"[LeetCode] 15. 3Sum [Medium]","parent":"Posts","content":"#15. 3Sum\n문제 설명 답 LeetCode Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\n1 2 Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2:\n1 2 Input: nums = [] Output: [] Example 3:\n1 2 Input: nums = [0] Output: [] Constraints:\n0 \u0026lt;= nums.length \u0026lt;= 3000 -105 \u0026lt;= nums[i] \u0026lt;= 105 "},{"id":22,"href":"/posts/jsReference/Array.prototype.push/","title":"[JS Reference]Array.prototype","parent":"Posts","content":" 설명 매개변수 ``optional\n예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 "},{"id":23,"href":"/tags/Reference/","title":"Reference","parent":"Tags","content":""},{"id":24,"href":"/categories/Reference/","title":"Reference","parent":"Categories","content":""},{"id":25,"href":"/posts/jsReference/Array.prototype.shift/","title":"[JS Reference]Array.prototype","parent":"Posts","content":" 설명 매개변수 ``optional\n예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 "},{"id":26,"href":"/posts/jsReference/Array.prototype.sort/","title":"[JS Reference] Array.prototype.sort()","parent":"Posts","content":" Array.prototype.sort() 설명 매개변수 ``optional\n예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 mozilla\n"},{"id":27,"href":"/posts/leetcode/20200707-leetcode-49/","title":"[LeetCode] 49. Group Anagrams","parent":"Posts","content":"#49. Group Anagrams\n문제 단어의 배열을 받아서, 단어를 구성하는 알파벳의 순서가 다르더라고 같은 알파벳 들로 구성된 단어들을 묶어서 배열로 반환하는 문제입니다.\nEX) \u0026rsquo;eat\u0026rsquo;, \u0026lsquo;ate\u0026rsquo;, \u0026rsquo;tea\u0026rsquo;는 같이 묶여서 반환 됩니다.\n설명 우선, 단어에 문자 순서가 다른 모든 단어를 찾고 저장하기 위해서 기준으로 알파벳 순으로 정렬된 단어를 만든다. 예를 들어 eat, ate, tae에서는 알파벳 순서로 aet가 키가 되는 것이다. 이 키를 만들기 위해서 split()으로 단어를 쪼개고, sort() 를 사용해서 알파벳의 순서를 정렬하고, join() 을 이용해서 배열을 다시 단어로 만듭니다. 이 키를 가지고 data라는 json을 만들고 모든 단어를 돌면서 값을 추가한다. 그리고 추가된 값을 반환 형식에 맞춰서 반환해준다.\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 var groupAnagrams = function(strs) { const data = {}; // 단어를 키로, anagram 단어들을 값으로 가진다. const result = []; // 리턴할 결과를 저장하는 배열 for(let str of strs) { // 주어진 단어 배열을 반복문으로 돌린다. const word = str.split(\u0026#39;\u0026#39;).sort().join(\u0026#39;\u0026#39;); // 주어진 단어를 쪼개고 정렬하고 합쳐서 key가 될 값으로 만든다. if (!data[word]) data[word] = []; // data에 없다면 초기화를 해주고, data[word].push(str); // 추가한다. } for(let key in data) { result.push(data[key]); // 반환할 값을 만든다. } return result; }; LeetCode Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\n1 2 Input: strs = [\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;,\u0026#34;tan\u0026#34;,\u0026#34;ate\u0026#34;,\u0026#34;nat\u0026#34;,\u0026#34;bat\u0026#34;] Output: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] Example 2:\n1 2 Input: strs = [\u0026#34;\u0026#34;] Output: [[\u0026#34;\u0026#34;]] Example 3:\n1 2 Input: strs = [\u0026#34;a\u0026#34;] Output: [[\u0026#34;a\u0026#34;]] Constraints:\n1 \u0026lt;= strs.length \u0026lt;= 104 0 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] consists of lower-case English letters. "},{"id":28,"href":"/tags/Array.prototype.join/","title":"Array.prototype.join()","parent":"Tags","content":""},{"id":29,"href":"/tags/String.prototype.split/","title":"String.prototype.split()","parent":"Tags","content":""},{"id":30,"href":"/posts/jsReference/String.prototype.replace/","title":"[JS Reference] String.prototype.replace()","parent":"Posts","content":" String.prototype.replace() 설명 replace() 메서드는 패턴에 일치하는 부분이 교체된 새로운 문자열을 반환한다.\n정규식, 문자열로 교체할 수 있다.\nvar newStr = str.replace(regexp|substr, newSubstr|function) 매개변수 regexppattern\n정규식 객체 또는 리터럴\nsubstrpattern\nsubstr을 찾아서 새로운 값으로 변경한다. 변경 되어야 하는 string\nnewSubStrreplacement\n변경될 string\nfunctionreplacement\n변경될 function\n반환 새로운 문자열을 반환하고 기존 문자열은 변경되지 않는다.\n예제 1 2 3 4 5 console.log(\u0026#39;hello world!\u0026#39;.replace(\u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;)); // output: \u0026#34;healo world!\u0026#34; console.log(\u0026#39;Hello! world! 123\u0026#39;.replace(/[^a-z0-9]/gi,\u0026#34;\u0026#34;)); // output: \u0026#34;Helloworld123\u0026#34; 참고 사이트 mozilla\n"},{"id":31,"href":"/posts/jsReference/String.prototype.toLowerCase/","title":"[JS Reference] String.prototype.toLowerCase()","parent":"Posts","content":" String.prototype.toLowerCase() 설명 toLowerCase() 메서드는 문자열을 소문자로 변환해 반환한다.\n예제 1 2 3 console.log(\u0026#39;Hello World!\u0026#39;.toLowerCase()); // output: hello world! 참고 사이트 mozilla\n"},{"id":32,"href":"/posts/leetcode/20200707-leetcode-819/","title":"[LeetCode] 819. Most Common Word","parent":"Posts","content":"#819. Most Common Word\n문제 주어진 문자열 paragraph에서 가장 많이 나온 단어를 반환하는 문제입니다. 단어는 대소문자를 구분하지 않으며 소문자로 리턴합니다.\n설명 우선 paragraph는 대소문자를 구분하지 않지 때문에 str.toLowerCase() 를 이용해서 전부 소문자로 변경해줍니다.\n그리고 str.replace() 를 통해 문자를 제외한 것들을 제거합니다. 문자만 남은 문자열에서 빈칸 \u0026rsquo; \u0026lsquo;을 기준으로 split()을 사용해서 자르고 단어의 배열로 만들어 줍니다. 이 단어의 배열을 돌면서 includes() 를 이용해서 banned에 포함되는 단어는 제외하하고, 단어를 키로, 나온 횟수를 값으로 가지는 data에 저장을하고, 이 data를 반복문으로 돌려 가장 많은 횟수를 가진 단어를 반환합니다.\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var mostCommonWord = function(paragraph, banned) { const data = {}; // 단어를 키로, 나온 횟수를 값으로 저장한다. // 입력 받은 paragraph에서 문자와 숫자를 제외하고 나머지를 제거한 후 소문자로 만든다. const str = paragraph.replace(/[^a-z]/gi,\u0026#34; \u0026#34;).toLowerCase(); const arr = str.split(\u0026#39; \u0026#39;); // \u0026#39; \u0026#39;을 기준으로 배열로 만든다 for (let s of arr) { // 이 배열을 돌면서 if (s !== \u0026#39;\u0026#39; \u0026amp;\u0026amp; !banned.includes(s)) { // 단어가 빈 값이 아니고, banned에 포함 안되는 경우에만. if (!data[s]) data[s] = 0; // 단어를 키로, 나온 횟수를 값으로 저장하는 data에 단어가 없으면 생성하고, data[s] += 1; // 횟수를 하나 증가 시킨다. } } let key = \u0026#39;\u0026#39;; // 가장 많이 나온 단어를 저장할 변수 for (let i in data) { const count = data[i]; if (!key) key = i; // 반복문을 처음 돌 때 첫 키값을 저장한다. if (count \u0026gt; data[key]) key = i; // key변수의 횟수보다 새로운 단어의 횟수가 많다면 key를 변경한다. } return key; }; LeetCode Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\nExample 1:\n1 2 3 4 5 6 7 8 9 Input: paragraph = \u0026#34;Bob hit a ball, the hit BALL flew far after it was hit.\u0026#34;, banned = [\u0026#34;hit\u0026#34;] Output: \u0026#34;ball\u0026#34; Explanation: \u0026#34;hit\u0026#34; occurs 3 times, but it is a banned word. \u0026#34;ball\u0026#34; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \u0026#34;ball,\u0026#34;), and that \u0026#34;hit\u0026#34; isn\u0026#39;t the answer even though it occurs more because it is banned. Example 2:\n1 2 graph = \u0026#34;a.\u0026#34;, banned = [] Output: \u0026#34;a\u0026#34; Input: para\nConstraints:\n1 \u0026lt;= paragraph.length \u0026lt;= 1000 paragraph consists of English letters, space \u0026rsquo; \u0026lsquo;, or one of the symbols: \u0026ldquo;!?\u0026rsquo;,;.\u0026rdquo;. 0 \u0026lt;= banned.length \u0026lt;= 100 1 \u0026lt;= banned[i].length \u0026lt;= 10 banned[i] consists of only lowercase English letters. "},{"id":33,"href":"/tags/Array.prototype.includes/","title":"Array.prototype.includes()","parent":"Tags","content":""},{"id":34,"href":"/tags/split/","title":"split()","parent":"Tags","content":""},{"id":35,"href":"/tags/String.prototype.replace/","title":"String.prototype.replace()","parent":"Tags","content":""},{"id":36,"href":"/tags/String.prototype.toLowerCase/","title":"String.prototype.toLowerCase()","parent":"Tags","content":""},{"id":37,"href":"/posts/leetcode/20200707-leetcode-937/","title":"[LeetCode] 937. Reorder Data in Log Files","parent":"Posts","content":"#937. Reorder Data in Log Files\n문제 입력 받은 로그들을 문자로 이루어진 로그는 문자 알파벳순으로, 숫자 로그는 입력 순서로 정렬한다. 같은 문자의 문자로그는 식별자에 따라 정렬한다.\n반환 순서는 정렬된 문자로그 + 입력 순서대로의 숫자로그 이다.\n설명 우선 제가 생각한 방법은 입력받은로그를 문자로그, 숫자로그로 분류하고, 숫자로그는 입력순으로 저장한다.\n문자로그는 앞에 식별자를 제외하고, 정렬작업을 진행한다.\n그 후 정렬된 문자로그 + 숫자로그의 배열을 반환한다.\n사용된 메소드 설명 split() join() shift() push() sort()\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var reorderLogFiles = function(logs) { const digit = []; // 숫자로그를 저장할 배열 const letter = []; // 문자로그를 저장할 배열 const result = []; // 최종으로 반환할 배열 for (let log of logs) { const arr = log.split(\u0026#39; \u0026#39;);// 입력 받은 로그를 split()으로 나눠서 arr.shift(); // 첫 번째는 식별자 이므로 제외하고. if (!isNaN(Number(arr.join(\u0026#39;\u0026#39;)))) { // 로그를 배열로 쪼갠걸 합쳐서 숫자로그인지 문자로그인지 확인 digit.push(log); } else { letter.push(log); } } letter.sort((a, b) =\u0026gt; { // 문자로그는 정렬해야되고, 문자가 같다면 let aStr = a.split(\u0026#39; \u0026#39;); // 로그를 쪼개서 배열로 만들고 const aIdentifier = aStr.shift(); // 같은 문자일 결우 사용할 식별자를 추출하고 aStr = aStr.join(\u0026#39; \u0026#39;); // 배열을 문자로 만든다. let bStr = b.split(\u0026#39; \u0026#39;); const bIdentifier = bStr.shift(); bStr = bStr.join(\u0026#39; \u0026#39;); if(aStr \u0026gt; bStr) return 1; if(aStr \u0026lt; bStr) return -1; if(aStr === bStr) { //문자가 같다면 식별자로 순서를 정한다. if (aIdentifier \u0026gt; bIdentifier) return 1; if (aIdentifier \u0026lt; bIdentifier) return -1; } return 0; }); for (let i = 0; i \u0026lt; letter.length; i++) { // 정렬된 문자로그를 반환할 배열에 먼저 넣고 result.push(letter[i]) } for (let i = 0; i \u0026lt; digit.length; i++) { // 입력 순서대로인 숫자 로그릴 반환할 배열에 넣는다. result.push(digit[i]) } return result; }; LeetCode You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\nThere are two types of logs:\nLetter-logs: All words (except the identifier) consist of lowercase English letters. Digit-logs: All words (except the identifier) consist of digits. Reorder these logs so that:\nThe letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers. The digit-logs maintain their relative ordering. Return the final order of the logs. Example 1:\n1 2 3 4 5 Input: logs = [\u0026#34;dig1 8 1 5 1\u0026#34;,\u0026#34;let1 art can\u0026#34;,\u0026#34;dig2 3 6\u0026#34;,\u0026#34;let2 own kit dig\u0026#34;,\u0026#34;let3 art zero\u0026#34;] Output: [\u0026#34;let1 art can\u0026#34;,\u0026#34;let3 art zero\u0026#34;,\u0026#34;let2 own kit dig\u0026#34;,\u0026#34;dig1 8 1 5 1\u0026#34;,\u0026#34;dig2 3 6\u0026#34;] Explanation: The letter-log contents are all different, so their ordering is \u0026#34;art can\u0026#34;, \u0026#34;art zero\u0026#34;, \u0026#34;own kit dig\u0026#34;. The digit-logs have a relative order of \u0026#34;dig1 8 1 5 1\u0026#34;, \u0026#34;dig2 3 6\u0026#34;. Example 2:\n1 2 Input: logs = [\u0026#34;a1 9 2 3 1\u0026#34;,\u0026#34;g1 act car\u0026#34;,\u0026#34;zo4 4 7\u0026#34;,\u0026#34;ab1 off key dog\u0026#34;,\u0026#34;a8 act zoo\u0026#34;] Output: [\u0026#34;g1 act car\u0026#34;,\u0026#34;a8 act zoo\u0026#34;,\u0026#34;ab1 off key dog\u0026#34;,\u0026#34;a1 9 2 3 1\u0026#34;,\u0026#34;zo4 4 7\u0026#34;] Constraints:\n1 \u0026lt;= logs.length \u0026lt;= 100 3 \u0026lt;= logs[i].length \u0026lt;= 100 All the tokens of logs[i] are separated by a single space. logs[i] is guaranteed to have an identifier and at least one word after the identifier.\n"},{"id":38,"href":"/tags/Array.prototype.push/","title":"Array.prototype.push()","parent":"Tags","content":""},{"id":39,"href":"/tags/Array.prototype.shift/","title":"Array.prototype.shift()","parent":"Tags","content":""},{"id":40,"href":"/posts/leetcode/20200707-leetcode-344/","title":"[LeetCode] 344. Reverse String","parent":"Posts","content":"#344. Reverse String\n문제 입력받은 문자 배열을 뒤집어라.\n설명 배열의 순서를 뒤집어 주는 reverse() 메소드를 사용해서 배열의 순서를 뒤집습니다.\n답 1 2 3 var reverseString = function(s) { return s.reverse(); }; LeetCode Write a function that reverses a string. The input string is given as an array of characters s.\nExample 1:\n1 2 Input: s = [\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] Example 2:\n1 2 Input: s = [\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] Output: [\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] Constraints:\n1 \u0026lt;= s.length \u0026lt;= 105 s[i] is a printable ascii character.\nFollow up: Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n"},{"id":41,"href":"/tags/reverse/","title":"reverse()","parent":"Tags","content":""},{"id":42,"href":"/posts/leetcode/20200707-leetcode-125/","title":"[LeetCode] 125. Valid Palindrome","parent":"Posts","content":"#125. Valid Palindrome\nstr.toLowerCase()\n문제 입력받은 문자열에서 영문자와 숫자만 고려해서(대소문자 무시) 회문인지 확인해서 true/ false 반환.\n설명 우선 회문은 뒤집어도 똑같은 문자열을 말합니다. 예를들어 기러기, 탄도유도탄, 다들 잠들다 같은 말입니다.\n소문자로 만들기 제가 생각한 방법은 주어진 문자열 s를 str.toLowerCase() 를 이용해서 소문자로 만들어 줍니다.\n숫자와 문자를 제외한 모든것 제거 그 후에 숫자와 문자를 제외한 모든것을 str.replace()를 이용해서 제거하고,\n문자열 뒤집기 문자열을 뒤집어 주기 위해서 split() 으로 문자열을 쪼개서 배열로 만들고, reverse() 를 이용해서 배열의 순서를 뒤집고, join() 을 이용해서 배열을 문자열로 만들고 나면 뒤집어진 문자열이 생성됩니다.\n반환하기 이 뒤집힌 문자열과 입력받은 문자열이 같은지 확인하고 결과를 리턴해줍니다.\n조금 더 자세한 설명은 답의 주석을 참고하세요!\n답 1 2 3 4 5 var isPalindrome = function(s) { const replace = s.toLowerCase().replace(/[^a-z0-9]/gi,\u0026#34;\u0026#34;); // 입력 받은 문자열을 소문자로 만들고 숫자와 문자를 제외한 것들 제거 if (replace === replace.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)) return true; // 위의 결과와 위의 결과의 순서를 뒤집은 값을 비교해서 회문인지 여부를 리턴한다. return false; // 회문이 아니면 false }; LeetCode Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nExample 1:\n1 2 3 4 Input: s = \u0026#34;A man, a plan, a canal: Panama\u0026#34; Output: true Explanation: \u0026#34;amanaplanacanalpanama\u0026#34; is a palindrome. Example 2:\n1 2 3 4 Input: s = \u0026#34;race a car\u0026#34; Output: false Explanation: \u0026#34;raceacar\u0026#34; is not a palindrome. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 2 * 105 s consists only of printable ASCII characters.\n"},{"id":43,"href":"/posts/jsReference/String.prototype.indexOf/","title":"[JS Reference] String.prototype.indexOf()","parent":"Posts","content":" String.prototype.indexOf() 설명 str.indexOf(searchValue[, fromIndex]) 메서드는 호출한 String에서 주어진 값과 일치하는 첫 번째 인덱스를 반환한다. 일치하는 값이 없으면 -1을 반환한다.\n매개변수 searchValue\n주어진 String에서 찾을 값, searchValue값이 없다면 문자열 undefined를 찾으려는 것으로 간주한다.\nfromIndexoptional 문자열에서 찾기 시작하는 위치 인덱스 값.\n반환값 첫 번째 인덱스를 반환하고, 찾을 수 없다면 -1을 반환한다.\n예제 1 2 3 4 5 6 7 8 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39;llo\u0026#39;)); // output: 2 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39; \u0026#39;)); // output: 5 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39;d\u0026#39;)); // output: 10 매개변수 사용법 1 2 3 4 5 6 7 8 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39;llo\u0026#39;, 10)); // output: -1 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39; \u0026#39;, 0)); // output: 5 console.log(\u0026#39;Hello World!\u0026#39;.indexOf(\u0026#39;l\u0026#39;, 5)); // output: 9 참고 사이트 mozilla\n"},{"id":44,"href":"/posts/jsReference/Array.prototype.includes/","title":"[JS Reference] Array.prototype.includes()","parent":"Posts","content":" Array.prototype.includes() 설명 arr.includes(valueToFind[, fromIndex]) 메서드는 배열이 특정 요소를 포함하고 있는지 확인한다.\n반환값은 true / false\n매개변수 valueToFind\n찾을 요소, 대소문자 구분\nfromIndexoptional\n찾기 시작할 위치 인덱스 기본값은 0이다.\n예제 1 2 3 4 5 6 7 8 console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;A\u0026#39;)); // output: true console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;C\u0026#39;)); // output: false console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;Apple\u0026#39;)); // output: true console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;apple\u0026#39;)); // output: false 매개변수 사용법 1 2 3 4 console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;A\u0026#39;, 10)); // output: false console.log([\u0026#39;H\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;Apple\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;Facebook\u0026#39;].includes(\u0026#39;Facebook\u0026#39;, 1)); // output: true 참고 사이트 mozilla\n"},{"id":45,"href":"/posts/leetcode/20200706-leetcode-14/","title":"[LeetCode] 14. Longest Common Prefix","parent":"Posts","content":"#14. Longest Common Prefix\n문제 주어진 문자열의 배열에서 가장 긴 접두사를 찾는 문제.\n설명 처음에는 접두사라는게 뭔지몰라서 가장긴 공통된 문자열을 찾는 줄 알고, 열심히 코드를 만들었습니다. 근데 Submit을 눌러보니 계속 틀렸다고 나와서 접두사를 검색해보고 다시 코드를 만들었습니다. 제가 실수로 만든 가장 긴 공통된 문자열을 찾는 코드는 아래 따로 설명하겠습니다.\n자세한 설명은 코드에 주석으로 적겠지만, 간단하게 말하면 입력받은 모든 문자열을 돌면서 가장긴 접두사를 찾습니다. indexOf() 를 사용해서 indexOf() 가 0 을 반환하는지 확인해서 접두사인지 확인할 수 있습니다.\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var longestCommonPrefix = function(strs) { let result = \u0026#39;\u0026#39;; // 반환할 가장 긴 접두사를 저장할 변수 if (strs.length === 0) return result; // 입력받은 배열 strs가 빈 배열이면 \u0026#39;\u0026#39;을 반환합니다. const str = strs[0]; // 어떤 문자열을 사용해도 상관없지만 그냥 첫 번째 문자열을 기준으로 잡습니다. for (let i = 0; i \u0026lt; str.length; i++) { // 첫 번째 문자열을 돌면서 한 문자씩 가져옵니다. const common = result + str[i]; // 새로운 문자를 추가한 문자열이 가장 긴 접두사인지 확인하기 위해 문자열을 만듭니다. for (let st of strs) { if (st.indexOf(common) !== 0) return result; // 입력받은 문자열들을 돌면서 새로운 긴 접두사가 문자열에 접두사로 있는지 확인합니다. // 없다면 이전가지의 문자가 가장 긴 접두사이므로 반환합니다. } result = common; // 현재 common이 가장 긴접두사 이므로 result를 common의 값으로 변겅합니다. } return result; }; 실수로 만든 가장 긴 공통된 문자열을 찾는 코드 우선! 입력받은 strs배열의 첫 번째 문자열을 기준으로 for문을 돌면서 하나씩 다른 문자열에 포함 되는지 확인합니다. 포함되는지 확인하는 방법은 includes()를 사용합니다. 포함 된다면 우리가 반환할 변수 result에 담고, 다음 문자로 넘어가면서 확인합니다. 자세한 설명은 코드에 주석으로 남기겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const longestCommonPrefix = function(strs) { let common = \u0026#39;\u0026#39;; // 현재 작업중인 공통된 문자열 const commonArray = []; // 공톤된 문자열들을 저장한 배열 if (strs.length === 0) return result; // 입력받은 배열 strs가 빈 배열이면 \u0026#39;\u0026#39;을 반환합니다. const firstStr = strs[0]; // 어떤 문자열을 사용해도 상관없지만 그냥 첫 번째 문자열을 기준으로 잡습니다. for (let i = 0; i \u0026lt; firstStr.length; i++) { // 첫 번째 문자열을 돌면서 한 문자씩 가져옵니다. common = common + firstStr[i]; // 우리가 반환하기 위해 가장 긴 문자열을 만들고 있는 common 변수와 새로운 문자를 합칩니다. for (let str of strs) { // 입력받은 문자열 배열을 돌면서 변수 common를 포함하고 있는지 확인합니다. if (!str.includes(common)) common = \u0026#39;\u0026#39;; // 만약 common이 포함 안되는 문자열이 있다면 이전 문자까지가 가장 긴 문자열이기 때문에 빈 문자열을 만듭니다. } if (common) commonArray.push(common); // 공통된 문자열이 있다면 공통된 문자열을 저장하는 배열에 저장합니다. } commonArray.sort((a,b) =\u0026gt; b.length - a.length) // 우리가 저장한 공통된 문자열의 배열을 문자열이 가장 긴 순서로 정렬합니다. return commonArray[0] || \u0026#39;\u0026#39;; // commonArray의 첫 요소가 가장 긴 공통된 문자열이기 때문에 반환합니다. }; console.log(${longestCommonPrefix([\u0026#34;refloweraaaa\u0026#34;,\u0026#34;flowaaaa\u0026#34;,\u0026#34;flightaaaa\u0026#34;])}); // OUTPUT: aaaa LeetCode Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026ldquo;\u0026rdquo;.\nExample 1:\n1 2 Input: strs = [\u0026#34;flower\u0026#34;,\u0026#34;flow\u0026#34;,\u0026#34;flight\u0026#34;] Output: \u0026#34;fl\u0026#34; Example 2:\n1 2 3 4 Input: strs = [\u0026#34;dog\u0026#34;,\u0026#34;racecar\u0026#34;,\u0026#34;car\u0026#34;] Output: \u0026#34;\u0026#34; Explanation: There is no common prefix among the input strings. Constraints:\n1 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] consists of only lower-case English letters.\n"},{"id":46,"href":"/tags/String.prototype.indexOf/","title":"String.prototype.indexOf()","parent":"Tags","content":""},{"id":47,"href":"/posts/leetcode/20200706-leetcode-13/","title":"[LeetCode] 13. Roman to Integer","parent":"Posts","content":"#13. Roman to Integer\n문제 로마 숫자는 일곱 가지 기호로 표시됩니다 : I, V, X, L, C, D와 M. 입력받은 로마 숫자를 정수로 변환해서 리턴하는 문제입니다.\n답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var romanToInt = function(s) { const romanNumerals = { \u0026#39;I\u0026#39;: 1, \u0026#39;V\u0026#39;: 5, \u0026#39;X\u0026#39;: 10, \u0026#39;L\u0026#39;: 50, \u0026#39;C\u0026#39;: 100, \u0026#39;D\u0026#39;: 500, \u0026#39;M\u0026#39;: 1000, }; let prev = 0; let result = 0; for(let i = 0; i\u0026lt;s.length; i++) { let current = romanNumerals[s[i]]; if (prev \u0026gt; 0 \u0026amp;\u0026amp; current \u0026gt; prev) result += - (prev * 2); result += current; prev = current; } return result; }; 설명 우선 제가 생각한 방법은 로마 숫자의 기본 값들은 json 변수에 저장하고, 규칙대로 코드를 짜봤습니다.\n###규칙\n로마 숫자는 큰수에서 작은수로 만들어진다. 작은수에서 큰수 순서로 적을 때는 큰수 - 작은수이다. ex) IV = 5 - 1 = 4\n입력 받은 문자열에서 문자 하나씩 가져와서 정수로 변환하고,\n이전에 가져왔던 정수보다 작다면 계속 더하고, 크다면 이전의 정수를 빼고, 현재 정수를 더 합니다.\nexample\nINPUT MCMXCIV\nM: +1000 여기서 result = 1000 C: +100 여기서 result = 1000 + 100 = 1100 M: +1000 여기서 이전 값인 C(+100) 보다 M(+1000)이 크기 때문에 2번 규칙에 따라 result = 1100 + 1000 - (2 * 100) = 1900 X: +10 여기서 result = 1900 + 10 = 1910 C: +100 여기서 이전 값인 X(+10)보다 C(+100)이 크기 때문에 2번 규칙에 따라 result = 1910 + 100 - (2 * 10) = 1990 I: +1 여기서 result = 1990 + 1 = 1991 V: +5 여기서 이전 값인 I(+1)보다 V(+5)이 크기 때문에 2번 규칙에 따라 result = 1991 + 5 - (2 * 1) = 1994 OUTPUT: 1994 LeetCode Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\nExample 1:\n1 2 Input: s = \u0026#34;III\u0026#34; Output: 3 Example 2:\n1 2 Input: s = \u0026#34;IV\u0026#34; Output: 4 Example 3:\n1 2 Input: s = \u0026#34;IX\u0026#34; Output: 9 Example 4:\n1 2 3 Input: s = \u0026#34;LVIII\u0026#34; Output: 58 Explanation: L = 50, V= 5, III = 3. Example 5:\n1 2 3 Input: s = \u0026#34;MCMXCIV\u0026#34; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 15 s contains only the characters (\u0026lsquo;I\u0026rsquo;, \u0026lsquo;V\u0026rsquo;, \u0026lsquo;X\u0026rsquo;, \u0026lsquo;L\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, \u0026lsquo;D\u0026rsquo;, \u0026lsquo;M\u0026rsquo;). It is guaranteed that s is a valid roman numeral in the range [1, 3999].\n"},{"id":48,"href":"/posts/jsReference/parseInt/","title":"[JS Reference] parseInt()","parent":"Posts","content":" parseInt(string, radix) 설명 매개변수 string는 문자열이 아니라면 문자열로 변환하고 선행 공백은 무시합니다.\nradixoptional 2와 36 사이의 진수(default가 10이 아니다.)\nstring 이 \u0026ldquo;0x\u0026rdquo; 나 \u0026ldquo;0X\u0026quot;로 시작한다면, radix 는 16(16진) string 이 \u0026ldquo;0\u0026quot;으로 시작한다면, radix 는 8(8진)이거나, 10(십진)입니다. string 이 다른 값으로 시작 된다면, radix 는 10(십진)입니다.\n반환값 주어진 string으로부터 분석한 radix진수의 정수를 반환합니다.\n숫자로 시작하고, 중간에 숫자가 아닌 문자가 나오는 경우는 문자를 무시하고 앞까지의 숫자를 리턴한다.\nNaN을 반환하는 경우: radix가 2보다 작거나 36보다 큰 경우 첫번째 non-whitespace 문자가 숫자로 변환되지 않는 경우\n예제 10진수를 리턴 1 2 3 4 5 6 7 8 9 10 console.log(parseInt(101)); // output: 101 console.log(parseInt(\u0026#34;101\u0026#34;)); // output: 101 console.log(parseInt(\u0026#34; 101\u0026#34;)); // output: 101 console.log(parseInt(\u0026#34; 1012a1\u0026#34;)); // output: 1012 console.log(parseInt(123, 10)); // output: 123 NaN를 리턴 1 2 3 4 console.log(parseInt(\u0026#34;a101\u0026#34;)); // output: NaN console.log(parseInt(\u0026#34;HelloWorld\u0026#34;)); // output: NaN 참고 사이트 mozilla\n"},{"id":49,"href":"/posts/jsReference/String.prototype.toString/","title":"[JS Reference] String.prototype.toString()","parent":"Posts","content":" String.prototype.toString() 설명 toString() 메소드는 지정된 객체를 나타내는 문자열을 반환합니다.\n예제 1 2 3 4 5 6 7 8 console.log(\u0026#39;asd\u0026#39;.toString()); // output: \u0026#39;asd\u0026#39; console.log(\u0026#39;2020\u0026#39;.toString()); // output: \u0026#39;2020\u0026#39; console.log(\u0026#39;2020Hello\u0026#39;.toString()); // output: \u0026#39;2020Hello\u0026#39; 참고 사이트 mozilla\n"},{"id":50,"href":"/posts/jsReference/Math.sign/","title":"[JS Reference] Math.sign()","parent":"Posts","content":" Math.sign() 설명 sign(x)는 매개변수를 숫자로 변경하고 x의 부호를 반환합니다.\n양수, 음수, 양수인 영 또는 음수인 영을 구분해서 1, -1, 0, -0을 반환합니다. 그게 아니라면 NaN을 반환합니다.\n예제 반환값이 1인 경우 1 2 3 4 5 6 7 8 9 10 11 console.log(Math.sign(10)); // output: 1 console.log(Math.sign(\u0026#34;20\u0026#34;)); // output: 1 console.log(Math.sign(24120)); // output: 1 console.log(Math.sign(1)); // output: 1 반환값이 -1인 경우 1 2 3 4 5 6 7 8 9 10 11 console.log(Math.sign(-10)); // output: -1 console.log(Math.sign(\u0026#34;-20\u0026#34;)); // output: -1 console.log(Math.sign(-24120)); // output: -1 console.log(Math.sign(-1)); // output: -1 반환값이 0인 경우 1 2 3 4 console.log(Math.sign(0)); // output: 0 console.log(Math.sign(null)); // output: 0 반환값이 -0인 경우 1 2 3 4 console.log(Math.sign(-0)); // output: -0 console.log(Math.sign(-null)); // output: -0 반환값이 NaN인 경우 1 2 3 4 5 6 7 8 9 10 11 console.log(Math.sign(undefined)); // output: NaN console.log(Math.sign()); // output: NaN console.log(Math.sign(NaN)); // output: NaN console.log(Math.sign(\u0026#39;test\u0026#39;)); // output: NaN 참고 사이트 mozilla\n"},{"id":51,"href":"/posts/jsReference/Math.abs/","title":"[JS Reference] Math.abs()","parent":"Posts","content":" Math.abs() 설명 Math.abs(v)는 v의 절대값을 반환합니다.\n예제 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(Math.abs(10)); // 결과: 10 console.log(Math.abs(-10)); // 결과: 10 console.log(Math.abs(\u0026#34;10\u0026#34;)); // 결과: 10 console.log(Math.abs(\u0026#34;-10\u0026#34;)); // 결과: 10 console.log(Math.abs(\u0026#34;-10a\u0026#34;)); // 결과: NaN 참고 사이트 mozilla\n"},{"id":52,"href":"/posts/jsReference/String.prototype.split/","title":"[JS Reference] String.prototype.split()","parent":"Posts","content":" String.prototype.split([separator[, limit]]) 설명 split() 메서드 string 객체를 구분자(separator)을 이용해서 여러개의 문자열로 나눈 배열을 반환합니다.\n매개변수 separatoroptional\n원본 문자열을 나눌 구분자 문자열이나 정규표현식을 사용할 수 있다.\nlimitoptional\n끊어진 문자열의 최대 개수\n예제 빈 문자열인 경우 1 2 3 const str = \u0026#39;\u0026#39;; console.log(str.split()); // output: [\u0026#34;\u0026#34;] 매개변수 사용법 1 2 3 const str = \u0026#39;Hello World\u0026#39;; console.log(str.split(\u0026#39; \u0026#39;, 1)); // output: [\u0026#34;Hello\u0026#34;] 참고 사이트 mozilla\n"},{"id":53,"href":"/posts/jsReference/Array.prototype.join/","title":"[JS Reference] Array.prototype.join()","parent":"Posts","content":" Array.prototype.join([separator]) 설명 join()은 배열의 모든 요소를 연결해서 하나의 문자열로 만들어 반환합니다.\n배열을 변경하지 않고 반환만 합니다.\n매개변수 separator optional\n배열의 각 요소를 구분 문자열을 지정합니다.\ndefault: ,로 연결\n예제 separator값이 default인 경우 1 2 3 4 5 6 7 8 const arr = [\u0026#39;apple\u0026#39;, \u0026#39;google\u0026#39;, \u0026#39;facebook\u0026#39;]; console.log(arr.join()); // output: \u0026#34;apple,google,facebook\u0026#34; console.log(arr); // output: [\u0026#39;apple\u0026#39;, \u0026#39;google\u0026#39;, \u0026#39;facebook\u0026#39;] 매개변수 사용법 sparator값이 \u0026lsquo;\u0026lsquo;인 경우 1 2 console.log(arr.join(\u0026#39;\u0026#39;)); // output: \u0026#34;applegooglefacebook\u0026#34; sparator값이 \u0026rsquo; \u0026lsquo;인 경우 1 2 console.log(arr.join(\u0026#39; \u0026#39;)); // output: \u0026#34;apple google facebook\u0026#34; sparator값이 \u0026lsquo;!\u0026lsquo;인 경우 1 2 console.log(arr.join(\u0026#39;!\u0026#39;)); // output: \u0026#34;apple!google!facebook\u0026#34; 참고 사이트 mozilla\n"},{"id":54,"href":"/posts/jsReference/Array.prototype.reverse/","title":"[JS Reference] Array.prototype.reverse()","parent":"Posts","content":" Array.prototype.reverse() 설명 reverse()는 배열의 순서를 뒤집고 뒤집힌 배열을 반환합니다.\n원본을 뒤집고 참조를 반환합니다.\n예제 1 2 3 4 5 6 7 8 9 10 11 const arr = [1,2,3,4,5]; console.log(arr); // output: [1, 2, 3, 4, 5] const reverse = arr.reverse(); console.log(reverse); // output: [5, 4, 3, 2, 1] console.log(arr); // output: [5, 4, 3, 2, 1] 참고 사이트 "},{"id":55,"href":"/posts/leetcode/20200705-LeetCode-9/","title":"[LeetCode] 9. Palindrome Number","parent":"Posts","content":" 9. Palindrome Number 문제 우선 Palindrome이 뭔지 몰라서 사전에 검색을 해보니\n회문(回文: madam이나 nurses run처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 단어나 구)\n이라고 나옵니다. 단어를 그대로 읽나 거꾸로 뒤집어 읽나 똑같은 단어를 말한다고 합니다. 예를들어 기러기는 그대로 읽어도 기러기, 거꾸로 읽어도 기러기가되니까 회문이 맞습니다!\n하지만 여기서는 문자 회문? 이니까 숫자로 값을 입력할 것 입니다. 예를들어 123이 들어오면 false를 반환하고 232가 들어오면 true를 반환합니다.\n답 1 2 3 4 5 var isPalindrome = function(x) { if (x \u0026lt; 0) return false; const palindrome = parseInt(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); return palindrome === x; }; 설명 제가 생각한 방법은,\n입력받은 숫자 x를 뒤집어서 회문을 만들고 이 회문이 x와 같은지 확인하는 방법입니다.\n우선 음수가 들어오면 - 때문에 회문이 될수가 없기 때문에 처음에 제일 먼저 음수인지 확인 후 음수이면 0을 반환하고,\n입력받은 숫자 x를 뒤집기 x를 toString() 을 사용해서 문자로 변경 후 split() 을 이용해서 배열로 만든 후 reverse() 를 사용해서 배열의 순서를 뒤집고, join() 을 사용해서 문자로 변경합니다. 이 문자를 parseInt() 로 숫자로 만들고 변수 palindrome에 할당합니다.\n회문인지 확인하기 변수 palindrome과 변수 x가 같은지 확인해서 회문 여부를 반환합니다.!\nLeetCode Given an integer x, return true if x is palindrome integer.\nAn integer is a palindrome when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.\nExample 1:\n1 2 Input: x = 121 Output: true Example 2:\n1 2 3 Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:\n1 2 3 Input: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Example 4:\n1 2 Input: x = -101 Output: false Constraints: -231 \u0026lt;= x \u0026lt;= 231 - 1\nFollow up: Could you solve it without converting the integer to a string?\n"},{"id":56,"href":"/tags/parseInt/","title":"parseInt()","parent":"Tags","content":""},{"id":57,"href":"/tags/toString/","title":"toString()","parent":"Tags","content":""},{"id":58,"href":"/posts/leetcode/20200705-leetcode-7/","title":"[LeetCode] 7. Reverse Integer","parent":"Posts","content":"#7. Reverse Integer\n문제 32비트 숫자를 입력받고 숫자를 뒤집에서 반환한다. 음수이면 -를 붙혀서 반환한다.\n설명 우선, 제가 생각한 방법은 입력받은 숫자를 양수/음수 구분없게 절대값으로 만들고, 숫자를 뒤집고, 입력받은 숫자였으면 -를 붙혀서 반환하는 방법을 생각했다. Math.abs() 를 이용해서 절대값을 만들고, toString() 을 이용해서 숫자를 문자로 바꾼다음,\nsplit() 으로 문자를 쪼개서 배열로 만들고, reverse() 를 이용해서 배열의 순서를 뒤집고, join() 을 이용해서 배열을 문자열로 만들고 Math.sign() 을 이용해서 x의 부호를 가져와 숫자의 부호를 넣어준다.\n답 1 2 3 4 5 var reverse = function(x) { const num = Math.abs(x).toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) * Math.sign(x); if (num \u0026gt;= 2147483647 || num \u0026lt;= -2147483647 ) return 0; return num; }; LeetCode Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\n1 2 Input: x = 123 Output: 321 Example 2:\n1 2 Input: x = -123 Output: -321 Example 3:\n1 2 Input: x = 120 Output: 21 Example 4:\n1 2 Input: x = 0 Output: 0 Constraints: -231 \u0026lt;= x \u0026lt;= 231 - 1\n"},{"id":59,"href":"/tags/Math.abs/","title":"Math.abs()","parent":"Tags","content":""},{"id":60,"href":"/tags/Math.sign/","title":"Math.sign()","parent":"Tags","content":""},{"id":61,"href":"/posts/leetcode/20200705-leetcode-1/","title":"[LeetCode] 1. Two Sum","parent":"Posts","content":" 1. Two Sum 문제 숫자로 이루어진 배열과, 숫자로된 타겟을 입력받아서 배열에서 타켓을 만들 수 있는 숫자의 인덱스를 반환.\n만약에 배열 [1, 3, 6, 7]과 타겟 8을 입력 받는다면 [0, 3]를 반환한다\n답 1 2 3 4 5 6 7 var twoSum = function(nums, target) { for (let i = 0; i \u0026lt; nums.length; i++) { const test = target - nums[i]; const index = nums.indexOf(test); if (index != -1 \u0026amp;\u0026amp; index !== i) return [i, nums.indexOf(test)]; } }; 설명 우선, nums에 있는 두 값으로 target을 만들어야 함으로\nnums에 있는 A + B = target이라 생각하고 A = target - B로 생각해서\nnums에 B가 있는지 확인하고, B가 있다면 그 index로 배열을 만들어서 리턴합니다.\nLeetcode Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\n1 2 3 Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\n1 2 Input: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\n1 2 Input: nums = [3,3], target = 6 Output: [0,1] Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 104 109 \u0026lt;= nums[i] \u0026lt;= 109 109 \u0026lt;= target \u0026lt;= 109 Only one valid answer exists. Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n"},{"id":62,"href":"/posts/leetcode/20200705-leetcode-start/","title":"Leetcode 계획","parent":"Posts","content":" Leetcode 시작. 언제든지 인터뷰를 볼 수 있도록 계속 코딩테스트를 준비할 예정입니다.\n물론 경력직의 이직에서 코딩테스트가 가장 중요한 것은 아니겠지만, 나중에 어떤 기회가 올 수 있을지 모르기 때문에! 열심히 준비해 보도록 하겠습니다.\n우선, Leetcode는 Easy 단계를 하나씩 순서대로 풀어보겠습니다.\n매일 한 문제씩 푸는 것은 목표로 달려보겠습니다!\n"},{"id":63,"href":"/posts/etc/first_post/","title":"시작.","parent":"Posts","content":" 이직. 예전에 블로그를 시작했던 것도 이직을 위해서 였는데 이번에도 이직을 준비하면서 블로그를 시작합니다.\n저번에는 hexo로 작업을 했지만 이번에는 Go언어를 배우고 있기 때문에 Hugo로 블로그를 만들었습니다.\n벌써 6년이 넘게 개발을 하고 있지만 아직 길을 못 찾고 있다는 느낌이 들어서 저의 다음을 위해 지식을 쌓고, 좋은 회사를 찾아가기 위한 노력을 기록하겠습니다.\n"},{"id":64,"href":"/posts/old/20190120-Hanoi/","title":"[javascript] 하노이 탑 (Hanoi Tower)","parent":"Posts","content":" 하노이 탑 하노이 탑은 다음과 같은 조건을 가지고 있다.\n한번에 하나의 원판만 이동 맨위에 있는 원판만 이동 가능 작은 원판 위에 큰 원판을 올리는 것은 불가능 중간의 막대는 임시적으로 이용 가능 n-1개를 A에서 B로 이동하고, n개를 A에서 C로 이동한다. 그리고 n-1개를 B에서 C로 이동한다.\n1 2 3 4 5 6 7 8 9 10 let hanoi = (n, from, temp, to) =\u0026gt; { if(n===1) console.log(`${n}을 ${from}에서 ${to}로 이동`); else { hanoi(n-1, from, to, temp); console.log(`${n}을 ${from}에서 ${to}로 이동`); hanoi(n-1, temp, from, to); } } hanoi(5, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 1을 A에서 C로 이동 2을 A에서 B로 이동 1을 C에서 B로 이동 3을 A에서 C로 이동 1을 B에서 A로 이동 2을 B에서 C로 이동 1을 A에서 C로 이동 4을 A에서 B로 이동 1을 C에서 B로 이동 2을 C에서 A로 이동 1을 B에서 A로 이동 3을 C에서 B로 이동 1을 A에서 C로 이동 2을 A에서 B로 이동 1을 C에서 B로 이동 5을 A에서 C로 이동 1을 B에서 A로 이동 2을 B에서 C로 이동 1을 A에서 C로 이동 3을 B에서 A로 이동 1을 C에서 B로 이동 2을 C에서 A로 이동 1을 B에서 A로 이동 4을 B에서 C로 이동 1을 A에서 C로 이동 2을 A에서 B로 이동 1을 C에서 B로 이동 3을 A에서 C로 이동 1을 B에서 A로 이동 2을 B에서 C로 이동 1을 A에서 C로 이동 Related Posts "},{"id":65,"href":"/tags/dev/","title":"dev","parent":"Tags","content":""},{"id":66,"href":"/tags/fibonacci/","title":"fibonacci","parent":"Tags","content":""},{"id":67,"href":"/tags/interview/","title":"interview","parent":"Tags","content":""},{"id":68,"href":"/posts/old/20190120-Fibonacci/","title":"[javascript] 피보나치 (Fibonacci)","parent":"Posts","content":" 피보나치 수열 0, 1, 1, 2, 3, 5, 8, 13, 21.... 피보나치는 0번째는 0, 첫 번째는 1 그 이후로는 이전 두개의 수를 더한 값을 갖는 수열이다.\nF(0) = 0, F(1) = 1, F(n) = F(n-2) + F(n-1)\n1 2 3 4 5 6 7 8 9 10 11 let fib = (num) =\u0026gt; { if(num \u0026lt;= 1) return num; return fib(num-1) + fib(num-2); } console.log(fib(1)) console.log(fib(2)) console.log(fib(3)) console.log(fib(4)) console.log(fib(5)) console.log(fib(6)) 1 2 3 4 5 6 1 1 2 3 5 8 재귀함수로 구현하면 간단하지만, 같은 계산을 여러번 진행하기 때문에 좋지는 않다.\n그래서 반복문으로 변경할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let fib = (num) =\u0026gt; { if(num \u0026lt;= 1) return num; let current = 1; let last = 0; for(let i = 2; i \u0026lt;= num; i++) { let tmp = current; current = current + last; last = tmp; } return current; } console.log(fib(1)) console.log(fib(2)) console.log(fib(3)) console.log(fib(4)) console.log(fib(5)) console.log(fib(6)) 1 2 3 4 5 6 1 1 2 3 5 8 Related Posts "},{"id":69,"href":"/tags/nodejs/","title":"nodejs","parent":"Tags","content":""},{"id":70,"href":"/posts/old/20190119-Sync-VS-Async/","title":"동기와 비동기","parent":"Posts","content":" 설명 동기 여러작업을 진행 할때 하나의 작업이 끝날때 까지 기다렸다가 다음 작업을 진행하는 것.\n비동기 여러작업을 진행 할때 하나의 작업을 실행하고 다음 작업으로 넘어간다. 이전에 실행한 작업은 작업이 끝나고 callback을 넘긴다.\n비유 간단하게 설명하면 동기는 카페에서 손님에게 주문을 받고 커피를 만들어서 전달하고 다음 손님으로 넘어가는 것 이고 비동기는 카페에서 손님에게 주문을 받고 진동벨을 준 다음 다음 손님의 주문으로 넘어가고, 손님의 커피가 제조가 완료되면 진동벨(callback)을 울려 해당 손님에게 전달한다.\n코드 동기 코드\n1 2 3 4 5 6 7 8 9 console.log(\u0026#39;1\u0026#39;); const data = fs.readFileSync(\u0026#39;/file.md\u0026#39;); console.log(data); console.log(\u0026#39;2\u0026#39;); // 1 // data.. // 2 비동기 코드\n1 2 3 4 5 6 7 8 9 10 11 12 console.log(\u0026#39;1\u0026#39;); fs.readFile(\u0026#39;/file.md\u0026#39;, (err, data) =\u0026gt; { if (err) throw err; console.log(data); console.log(\u0026#39;2\u0026#39;); }); console.log(\u0026#39;3\u0026#39;); // 1 // 3 // data.. // 2 동기 코드는 우리가 생각하는 순서대로 결과가 나온다. 비동기 코드는 우리의 생각과 다르게 fs.readFile를 처리하는 동안 다음으로 넘어가서 3이 출력되고 함수가 다 처리되면 callback함수의 처리가 이루어진다.\n참고 node\nRelated Posts "},{"id":71,"href":"/posts/old/20190119-Process-VS-Thread/","title":"프로세스(Process) vs 쓰레드(Thread)","parent":"Posts","content":" 프로세스 프로세스는 실행중인 프로그램이다. 디스크로에서 메모리로 적재되어 CPU의 할당을 받을 수 있다. 쓰레드 프로세스의 실행단위 한 프로세스 내에서 동작되는 여러 실행으로 프로세스내의 주소공간이나 자원을 공유한다. 멀티 쓰레드 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 쓰레드 간의 공유된 자원을 사용해 쓰레드간의 통신이 간단하고 빠르다 멀티 쓰레드 문제점 자원을 공유하기 때문에 신경을 써야한다. 동기화 작업으로 인해 성능이 저하될 수 있다. 요약 프로세스는 운영체제로 부터 자원을 할당받는 자원단위(실행중인 프로그램) 쓰레드는 프로세스가 할당 받은 자원을 이용하는 실행 단위()\n멀티 쓰레드는 적은 메모리 사용과 빠르지만 자원을 공유해 신경쓸 것이 많다. 멀트 프로세스는 자원을 많이 사용하지만 공유된 자원이 없어 신경쓸 것이 적다.\nRelated Posts "},{"id":72,"href":"/posts/old/20190118-Queue-Using-Stacks/","title":"[자료구조][자바스크립트] 스택으로 큐 구현 javascript","parent":"Posts","content":"오늘은 스택으로 큐를 구현하는 문제를 살펴보겠습니다. 스택은 LIFO - Last In First Out 방식이다. 간단하게 설명하면 책상 위에 책을 하나씩 쌓아두고 위에서부터 하나씩 집어서 읽는 것이다.\n나중에 쌓은(제일 위에 있는) 책을 먼저 집어서 읽는 방식 큐는 FIFO - First In First Out 방식이다. 간단하게 설명하면 카페에서 한 줄로 서서 주문을 하는 것이다.\n제일 먼저 온 사람이 먼저 계산하는 방식 스택과 큐에 대한 설명과 코드는 이 블로그의 글을 참조하고, 오늘은 스택으로 큐를 구현해 보겠습니다.\n문제 스택을 사용하여 큐를 구현하여라\nenqueue dequeue peek length isEmpty 힌트 스택으로 큐를 구현하기 위해서는 스택을 두 개 사용하여야 한다. 하나는 inStack(enqueue시 쌓이는 스택), 다른 하나는 outStack(dequeue시 꺼내는 스택)\n설명 Enqueue outStack이 비어있는지 확인하고, outStack에 data가 있다면, inStack으로 옮겨준다. outStack이 비어있다면, inStack에 데이터를 넣는다. Dequeue inStack이 비어있는지 확인하고, inStack에 data가 있다면, outStack으로 옮겨준다. inStack이 비어있다면, outStack에서 data를 뽑는다. Enqueue 설명 stack을 두개를 만든다. 하나는 Enqueue할 때 사용하는 inStack, 다른 하나는 Dequeue할 때 사용하는 outStack. outStack이 비어있다면, inStack에 데이터를 넣는다.\ninStack이 비어있는지 확인하고, inStack에 data가 있다면, outStack으로 옮겨주고 data를 inStack으로 넣는다.\nDequeue 설명 inStack이 비어있는지 확인하고, inStack에 data가 있다면, outStack으로 옮겨준다.\ninStack이 비어있다면, outStack에서 data를 뽑는다.\n코드 javascript 로 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 const stack = () =\u0026gt; { let stackArray = []; return { push(item) { stackArray.push(item); }, pop() { return stackArray.pop(); }, peek() { return stackArray[stackArray.length - 1]; }, get length() { return stackArray.length; }, isEmpty() { return stackArray.length === 0; }, } } const queue = () =\u0026gt; { const inStack = stack(); const outStack = stack(); return { enqueue(item) { if(!outStack.isEmpty()) { while(!outStack.isEmpty()) { inStack.push(outStack.pop()); } } inStack.push(item); }, dequeue() { if(!inStack.isEmpty()) { while(!inStack.isEmpty()) { outStack.push(inStack.pop()); } } return outStack.pop(); }, peek() { if(!inStack.isEmpty()) { while(!inStack.isEmpty()) { outStack.push(inStack.pop()); } } return outStack.peek(); }, get length() { if(!inStack.isEmpty()) { while(!inStack.isEmpty()) { outStack.push(inStack.pop()); } } return outStack.length; }, isEmpty() { return this.length === 0; } } } const q = queue(); console.log(q.isEmpty()) q.enqueue(1) console.log(q.peek()) q.enqueue(2) q.enqueue(3) console.log(q.peek()) q.enqueue(4); console.log(q.dequeue()); console.log(q.isEmpty()) console.log(q.dequeue()); 결과 1 2 3 4 5 6 true 1 1 1 false 2 Related Posts "},{"id":73,"href":"/tags/datastructure/","title":"datastructure","parent":"Tags","content":""},{"id":74,"href":"/tags/queue/","title":"queue","parent":"Tags","content":""},{"id":75,"href":"/tags/stack/","title":"stack","parent":"Tags","content":""},{"id":76,"href":"/posts/old/20190118-Codewars-Greed-is-Good/","title":"[Codewars] 주사위 게임 \"Greed is Good\"","parent":"Posts","content":" 설명 문제 주사위(1-6)를 굴려서 나온 수에 따른 점수를 매겨라.\n1 2 3 4 5 6 7 8 Three 1\u0026#39;s =\u0026gt; 1000 points Three 6\u0026#39;s =\u0026gt; 600 points Three 5\u0026#39;s =\u0026gt; 500 points Three 4\u0026#39;s =\u0026gt; 400 points Three 3\u0026#39;s =\u0026gt; 300 points Three 2\u0026#39;s =\u0026gt; 200 points One 1 =\u0026gt; 100 points One 5 =\u0026gt; 50 point 1 2 3 4 5 Throw Score --------- ------------------ 5 1 3 4 1 50 + 2 * 100 = 250 1 1 1 3 1 1000 + 100 = 1100 2 4 4 5 4 400 + 50 = 450 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function score( dice ) { let scores = {}; let returnValue = 0; for(let i in dice) { if(scores[dice[i]]) { scores[dice[i]]++; }else { scores[dice[i]] = 1; } } for(let i in scores) { let s = scores[i]; if(i == 1 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 1000; s -=3;} if(i == 2 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 200; s -=3;} if(i == 3 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 300; s -=3;} if(i == 4 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 400; s -=3;} if(i == 5 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 500; s -=3;} if(i == 6 \u0026amp;\u0026amp; s \u0026gt;= 3) {returnValue += 600; s -=3;} if(i == 1) returnValue += s * 100; if(i == 5) returnValue += s * 50; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 function score( dice ) { var dc = [0,0,0,0,0,0]; var tdr = [1000,200,300,400,500,600]; var sdr = [100,0,0,0,50,0]; dice.forEach(function(x){ dc[x-1]++; }); return dc.reduce(function(s,x,i){ return s + (x \u0026gt;= 3? tdr[i] : 0) + sdr[i]*(x % 3); },0); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function score( dice ) { var six=0, five=0, four=0, three=0, too=0, one=0; var i = 0; while (i \u0026lt; 5) { if (dice[i] == 6) { six++; } if (dice[i] == 5) { five++; } if (dice[i] == 4) { four++; } if (dice[i] == 3) { three++; } if (dice[i] == 2) { too++; } if (dice[i] == 1) { one++; } i++; } var r = 0; if (one \u0026gt; 2) { r += 1000; one -= 3;} if (six \u0026gt; 2) { r += 600; } if (five \u0026gt; 2) { r += 500; five -= 3;} if (four \u0026gt; 2) { r += 400; } if (three \u0026gt; 2) { r += 300; } if (too \u0026gt; 2) { r += 200; } r += one * 100; r += five * 50; return r; } 해설 출처 codewars\nRelated Posts "},{"id":77,"href":"/categories/Codewars/","title":"Codewars","parent":"Categories","content":""},{"id":78,"href":"/tags/codingtest/","title":"codingtest","parent":"Tags","content":""},{"id":79,"href":"/posts/old/20190118-Codewars-Give-me-a-Diamond/","title":"[Codewars] 다이아몬드 모양 출력 \"Codewars_Give_me_a_Diamond\"","parent":"Posts","content":" 설명 문제 n을 입력받아서 다이아몬드 모양을 출력하는 문제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function diamond(n){ if(n \u0026lt; 0 || n%2 ==0) return null; let returnValue = \u0026#39;\u0026#39;; for(let i = 1;i\u0026lt;=n;i+=2) { for(let j=0;j\u0026lt;(n-i)/2;j++) returnValue += \u0026#39; \u0026#39;; for(let j=0;j\u0026lt;i;j++)returnValue += \u0026#39;*\u0026#39;; returnValue +=\u0026#39;\\n\u0026#39;; } for(let i = n-2; i\u0026gt;0; i-=2) { for(let j=0;j\u0026lt;(n-i)/2;j++) returnValue += \u0026#39; \u0026#39;; for(let j=0;j\u0026lt;i;j++)returnValue += \u0026#39;*\u0026#39;; returnValue +=\u0026#39;\\n\u0026#39;; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 10 11 12 function diamond(n){ if( n%2==0 || n\u0026lt;1 ) return null var x=0, add, diam = line(x,n); while( (x+=2) \u0026lt; n ){ add = line(x/2,n-x); diam = add+diam+add; } return diam; } function repeat(str,x){return Array(x+1).join(str); } function line(spaces,stars){ return repeat(\u0026#34; \u0026#34;,spaces)+repeat(\u0026#34;*\u0026#34;,stars)+\u0026#34;\\n\u0026#34;; } 1 2 3 4 5 6 7 8 9 10 11 12 function diamond(n){ if (n \u0026lt; 0 || !(n % 2)) return null; const middleIndex = Math.floor(n / 2); return Array.apply(null, {length: n}) .map((el, index) =\u0026gt; { const indentation = Math.abs(index - middleIndex); const numberOfAsterisks = n - indentation * 2; return Array(indentation + 1).join(\u0026#39; \u0026#39;) + Array(numberOfAsterisks + 1).join(\u0026#39;*\u0026#39;); }) .join(\u0026#39;\\n\u0026#39;) + \u0026#39;\\n\u0026#39;; } 해설 출처 codewars\nRelated Posts "},{"id":80,"href":"/posts/old/20190118-Codewars-Reverse-Polish-Notation-Calculator/","title":"[Codewars] 후위표기법 문제 \"Reverse polish notation calculator\"","parent":"Posts","content":"우리가 알고있는 수식은 5 + ((1 + 2) * 4) - 3 같은 식이다. 하지만 후위표기법에서는 5 1 2 + 4 * + 3 -이런식으로 표현한다.\n문제 후위표기법으로 제공되는 식을 풀어 답을 리턴하시오.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function calc(expr) { let exp = expr.split(\u0026#39; \u0026#39;); let expStack = []; let returnValue = 0; for(let i in exp) { let val = exp[i]; let num1; let num2; if(val == \u0026#39;+\u0026#39; ||val == \u0026#39;-\u0026#39; ||val == \u0026#39;*\u0026#39; ||val == \u0026#39;/\u0026#39;) { num1 = Number(expStack.pop()); num2 = Number(expStack.pop()); } switch(val) { case \u0026#39;+\u0026#39;: expStack.push(num2 + num1); break; case \u0026#39;-\u0026#39;: expStack.push(num2 - num1); break; case \u0026#39;*\u0026#39;: expStack.push(num2 * num1); break; case \u0026#39;/\u0026#39;: expStack.push(num2 / num1); break; default : if(val) expStack.push(val) } } return Number(expStack[0]) || 0; } 다른 답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var operands = { \u0026#39;+\u0026#39;: function (b, a) { return a + b;}, \u0026#39;-\u0026#39;: function (b, a) { return a - b;}, \u0026#39;*\u0026#39;: function (b, a) { return a * b;}, \u0026#39;/\u0026#39;: function (b, a) { return a / b;} }; function calc(expr) { expr = expr || \u0026#39;0\u0026#39;; return +expr.split(/\\s/g).reduce(function (stack, current) { stack.push(operands[current] ? operands[current](+stack.pop(), +stack.pop()) : current); return stack; }, []).pop(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function calc(expr) { var result = []; var atoms = expr.split(/\\s+/); var operators = [\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;/\u0026#39;]; for (var i=0; i\u0026lt;atoms.length; i++) { switch(atoms[i]) { case \u0026#39;+\u0026#39;: result.push(result.pop() + result.pop()); break; case \u0026#39;-\u0026#39;: result.push(-result.pop() + result.pop()); break; case \u0026#39;*\u0026#39;: result.push(result.pop() * result.pop()); break; case \u0026#39;/\u0026#39;: result.push(1 /(result.pop() / result.pop())); break; default: result.push(parseFloat(atoms[i])); } } return result.pop() || 0; } 해설 출처 codewars\nRelated Posts "},{"id":81,"href":"/posts/old/20190117-Javascript-Linked-List/","title":"[자료구조][자바스크립트] 연결리스트(linked list)","parent":"Posts","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const linkedListNode = class LinkedListNode { constructor(value, next = null) { this.value = value; this.next = next; } } const linkedList = class LinkedList { constructor() { this.head = null; this.length = 0; } append(value) { const node = new linkedListNode(value); let current = this.head; if (!current) { // 리스트가 비어있음 this.head = node; this.length++; return node; } else { while (current.next) { //리스트의 끝을 찾아서 current = current.next; } current.next = node; //끝에 추가 this.length++; return node; } } find(position) { let current = this.head; let count = 0; while (count \u0026lt; position) { current = current.next; count++; } return current? current.value : null; } delete(position) { let current = this.head; let before; let remove; let count = 0; if (position == 0) { //제일 앞 삭제 remove = this.head; this.head = this.head.next; this.length--; return remove; } else { console while (count \u0026lt; position) { before = current; count++; current = current.next; } remove = current; before.next = remove? remove.next : null; this.length--; return remove; } } } let testLink = new linkedList(); console.log(testLink); testLink.append(3); console.log(testLink) testLink.append(4); console.log(testLink) console.log(testLink.delete(1)) console.log(testLink) 1 2 3 4 5 6 7 8 LinkedList { head: null, length: 0 } LinkedList { head: LinkedListNode { value: 3, next: null }, length: 1 } LinkedList { head: LinkedListNode { value: 3, next: LinkedListNode { value: 4, next: null } }, length: 2 } LinkedListNode { value: 4, next: null } LinkedList { head: LinkedListNode { value: 3, next: null }, length: 1 } Related Posts "},{"id":82,"href":"/tags/linkedlist/","title":"linkedlist","parent":"Tags","content":""},{"id":83,"href":"/posts/old/20190117-Rest-API/","title":"REST API","parent":"Posts","content":" REST API REST (Representational State Transfer) web의 장점을 최대한 활용할 수 있는 아키텍쳐 HTTP 메서드 메서드 의미 멱등성 POST Create x GET Select O PUT Update O DELETE Delete O 멱등성 : 연산을 여러번해도 달라지지 않는것. REST는 상태 없이 API를 수행한다 그래서 여러 API를 호출하다 실패시 복구해야 하는데 멱등성 메서드는 복구가 필요없다. REST는 리소스 지향으로 모든 것은 명사로 표현한다. 각 세부 리소스에는 ID를 추가한다. REST API의 특성 유니폼 인터페이스 : 표준만 따르면 어떤 기술이라도 사용가능 무상태성 / 스테이트리스 : 서버는 상태를 저장하지 않으므로 각 API 서버는 들어오는 요청만 수행, 구현이 단순 캐슁가능 : HTTP에서 제공하는 캐슁 가능 자체 표현구조 : REST API만 보고 쉽게 이해할 수 있다. Client - Server 구조 : 서버는 API를 제공하고 클라이언트는 세션, 로그인 정보등을 직접 관리 계층형 구조 참고자료 API 디자인 REST API 제대로 알고 사용하기\nRelated Posts "},{"id":84,"href":"/tags/restapi/","title":"restapi","parent":"Tags","content":""},{"id":85,"href":"/tags/%EC%9D%B4%EC%A7%81/","title":"이직","parent":"Tags","content":""},{"id":86,"href":"/tags/http/","title":"http","parent":"Tags","content":""},{"id":87,"href":"/tags/https/","title":"https","parent":"Tags","content":""},{"id":88,"href":"/posts/old/20190117-http-vs-https/","title":"http와 https","parent":"Posts","content":" Related Posts http (Hyper Text Transfer Protocol) Client와 Server가 메세지를 주고 받는 통신 규약 http://로 시작 메세지를 암호화 하지 않음 https (Hyper Text Transfer Protocol Secure Socket Layer) Client와 Server가 메세지를 주고 받는 통신 규약 https://로 시작 메세지를 암호화함 공개키, 개인키 암호화 SSL 인증서 구입 비용과 갱신 비용이 비싸다 암호화로 속도가 느리다 Related Posts "},{"id":89,"href":"/posts/old/20190117-Javascript-Queue/","title":"[자료구조][자바스크립트] 큐(Queue)","parent":"Posts","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function createQueue() { const queue = []; return { enqueue(item) { queue.unshift(item); }, dequeue() { return queue.pop(); }, peek() { return queue[queue.length -1]; }, get length() { return queue.length; }, isEmpty() { return queue.length === 0; } } } const q = createQueue(); q.enqueue(1); q.enqueue(2); q.enqueue(3); q.enqueue(4); console.log(q.isEmpty()); console.log(q.length) console.log(q.dequeue()); console.log(q.length) console.log(q.peek()) console.log(q.length) 1 2 3 4 5 6 false 4 1 3 2 3 Related Posts "},{"id":90,"href":"/posts/old/20190117-Javascript-Stack/","title":"[자료구조][자바스크립트] 스택(Stack)","parent":"Posts","content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function createStack() { const stack = []; return { push(item) { stack.push(item); }, pop() { return stack.pop(); }, peek() { return stack[stack.length - 1]; }, get length() { return stack.length; }, isEmpty() { return stack.length === 0; } } } const s = createStack(); s.push(1); s.push(2); s.push(3); console.log(s.length) console.log(s.peek()); console.log(s.pop()); console.log(s.length) console.log(s.pop()) 1 2 3 4 5 3 3 3 2 2 Related Posts "},{"id":91,"href":"/tags/2019/","title":"2019","parent":"Tags","content":""},{"id":92,"href":"/posts/old/20190114-2019-Plan/","title":"2019년도 계획.","parent":"Posts","content":" 2018.. 2019년의 계획을 세우기 전에 2018년을 돌아보면 정신적으로 힘들일의 연속이였다. 오래 일하던 회사 사정으로 갑자기 이직을 준비해야 하는 상황이 주어졌다. 여러 가지 일들로 정신력이 탈탈 털리고 아직 정신을 회복하고 있다.\n그래도 2019년에는 좋은일이 많을 거라고 예상하면서 2019년 계획을 세워보기로 한다.\n이직 새로운 언어 공부 javascript 더 집중적으로 공부 블로그 시작하기 다이어트 유튜브 시작하기 github에 코드 올리기 개인 프로젝트 진행 우선 이직이 제일 급한 문제이기 때문에 이직에 관련된 글들을 많이 작성할 예정입니다. 면접 질문, 알고리즘, 자료구조 등등\n하루에 하나 정도는 올리는 게 목표인데 어떻게 될지는 모르겠다.\nRelated Posts "},{"id":93,"href":"/tags/plan/","title":"plan","parent":"Tags","content":""},{"id":94,"href":"/categories/Plan/","title":"Plan","parent":"Categories","content":""},{"id":95,"href":"/tags/%EA%B3%84%ED%9A%8D/","title":"계획","parent":"Tags","content":""},{"id":96,"href":"/posts/old/20190114-improve-nested-conditionals/","title":"[jstips] 중첩된 조건문 개선 if, switch","parent":"Posts","content":"\n중첩된 조건문 개선 jstips에서 javascript를 사용할 때 중첩된 if문을 조금 더 깔끔하고 효율적으로 만들 수 있을지에 대해서 읽었습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (color) { if (color === \u0026#39;black\u0026#39;) { printBlackBackground(); } else if (color === \u0026#39;red\u0026#39;) { printRedBackground(); } else if (color === \u0026#39;blue\u0026#39;) { printBlueBackground(); } else if (color === \u0026#39;green\u0026#39;) { printGreenBackground(); } else { printYellowBackground(); } } 우선 중첩된 if문을 개선하는 방법 중에 하나는 switch문을 사용하는 것입니다. switch문을 사용하면 더 짧고 깔끔하게 만들 수 잇지만 **break;**를 생략하는 것과 같은 오류를 디버깅하기에 어렵기 때문에 사용하지 않는 것이 좋습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch(color) { case \u0026#39;black\u0026#39;: printBlackBackground(); break; case \u0026#39;red\u0026#39;: printRedBackground(); break; case \u0026#39;blue\u0026#39;: printBlueBackground(); break; case \u0026#39;green\u0026#39;: printGreenBackground(); break; default: printYellowBackground(); } 조건문에 여러 가지 조건이 들어가는 경우에도 조건문을 짧고 깔끔하게 쓰고 싶다면 switch를 사용할 수 있습니다. 이 경우에는 switch문의 파라미터로 true를 넣고, case에 아래처럼 조건을 넣으면 가능합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch(true) { case (typeof color === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; color === \u0026#39;black\u0026#39;): printBlackBackground(); break; case (typeof color === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; color === \u0026#39;red\u0026#39;): printRedBackground(); break; case (typeof color === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; color === \u0026#39;blue\u0026#39;): printBlueBackground(); break; case (typeof color === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; color === \u0026#39;green\u0026#39;): printGreenBackground(); break; case (typeof color === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; color === \u0026#39;yellow\u0026#39;): printYellowBackground(); break; } 리팩토링 같은 걸 생각할 필요가 없다면, 각 색의 함수를 만드는 것 대신에 색을 인수로 갖는 함수를 만들어서 해결할 수도 있습니다.\n1 2 3 4 5 6 function printBackground(color) { if (!color || typeof color !== \u0026#39;string\u0026#39;) { return; // Invalid color, return immediately } } 그러나 만약 리팩토링도 생각해야 한다면, 여러번 조건을 확인하고 swtich문을 사용하는 것을 피해야 합니다.\n결론 중첩된 if문을 개선하는 가장 효율 적인 방법은 object를 사용하는 방법입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 var colorObj = { \u0026#39;black\u0026#39;: printBlackBackground, \u0026#39;red\u0026#39;: printRedBackground, \u0026#39;blue\u0026#39;: printBlueBackground, \u0026#39;green\u0026#39;: printGreenBackground, \u0026#39;yellow\u0026#39;: printYellowBackground }; if (color in colorObj) { colorObj[color](); } Related Posts "},{"id":97,"href":"/tags/jstips/","title":"jstips","parent":"Tags","content":""},{"id":98,"href":"/posts/old/20190114-insert-item-inside-an-array/","title":"[jstips] 배열에 요소 추가하기 push(),concat(),unshift()","parent":"Posts","content":" 오늘은 jstips에서 첫 번째 팁인 배열에 요소 추가하는 방법을 공부해보겠습니다.\n저도 개발을 하다 보면 배열에 요소를 추가하는 작업을 많이 하게 되는데, push()를 사용해서 배열의 끝에 요소를 넣고, unshift를 사용해서 배열의 시작 부분에 요소를 넣고, splice를 사용해서 배열의 중간에 요소를 넣는 것은 알고 그렇게 작업을 했었습니다. 근데 jstips에서 글을 읽으면서 속도와 성능을 생각하면서 작업을 하는 것도 필요할 것 같다는 생각이 들었습니다.\n귀찮은 분들을 위해 맨 아래에 결론을 적어놨습니다!\n배열의 끝부분에 추가 배열의 끝에 요소를 추가하는 방법 중 제일 쉬운 방법은 push()를 사용하는 것인데, 다른 방법들도 있다.\n1 2 3 4 5 6 var arr = [1,2,3,4,5]; var arr2 = []; arr.push(6); arr[arr.length] = 6; arr2 = arr.concat([6]); // concat은 배열을 반환한다. 모바일에서의 성능 Android (v.4.2.2)\narr.push(6); and arr[arr.length] = 6; 비슷한 성능을 보인다. //3,319,694 ops/sec arr2 = arr.concat([6[); 다른 두가지 방법보다 50ㅋ.61% 느리다. Chrome Mobile (v33.0.0)\narr[arr.length] = 6; //6,125,975 ops/sec arr.push(6); 66.74% 느리다. arr2 = arr.concat([6]); 49.78% 느리다. Safari Mobile (v9)\narr[arr.length] = 6; //7,452,898 ops/sec arr.push(6); 40.19 % 느리다. arr2 = arr.concat([6]); 49.78% 느리다. 최종 순위 arr[arr.length] = 6; //평균 5,632,856 ops/sec arr.push(6); // 35.64% 더 느리다. arr2 = arr.concat([6]); // 62.67% 더 느리다. 데스크탑에서의 성능 Chrome (v48.0.2564)\narr[arr.length] = 6; // 21,601,722 ops/sec arr.push(6); 61.94 % 더 느리다. arr2 = arr.concat([6]); 87.45% 더 느리다. Firefox (v44)\narr[arr.length] = 6; //56,032,805 ops/sec arr.push(6); 0.52 % 더 느리다. arr2 = arr.concat([6]); 87.36% 더 느리다. IE (v11)\narr[arr.length] = 6; //67,197,046 ops/sec arr.push(6); 39.61 % 더 느리다. arr2 = arr.concat([6]); 93.41% 더 느리다. Opera (v35.0.2066.68)\narr[arr.length] = 6; // 30,775,071 ops/sec arr.push(6); 71.60 % 더 느리다. arr2 = arr.concat([6]); 83.70% 더 느리다. Safari (v9.0.3)\narr[arr.length] = 6; //42,670,978 ops/sec arr.push(6); 0.80 % 더 느리다. arr2 = arr.concat([6]); 76.07% 더 느리다. 최종 순위 arr[arr.length] = 6; //평균 42,345,449 ops/sec arr.push(6); //34.66 % 더 느리다. arr2 = arr.concat([6]); //85.79% 더 느리다. 배열의 앞부분에 추가 1 2 3 4 var arr = [1,2,3,4,5]; arr.unshift(0); [0].concat(arr); 여기서 주의할 점은 unshift는 원래의 배열을 수정하고, concat은 새로운 배열을 반환한다.\n모바일에서의 성능 Android (v4.2.2)\n[0].concat(arr); // 1,808,717 ops/sec arr.unshift(0); 98.85% 더 느리다. Chrome Mobile (v33.0.0)\n[0].concat(arr); // 1,269,498 ops/sec arr.unshift(0); 99.86% 더 느리다. Safari Mobile(v9)\n[0].concat(arr); // 3,250,184 ops/sec arr.unshift(0); 33.67% 더 느리다. 최종 순위 1.[0].concat(arr); //평균 4,972,622 ops/sec 2.arr.unshift(0); // 64.70% 더 느리다.\n데스크탑에서의 성능 Chrome (v48.0.2564)\n[0].concat(arr); // 2,656,685 ops/sec arr.unshift(0); 96.77% 더 느리다. Firefox (v44)\n[0].concat(arr); // 8,039,759 ops/sec arr.unshift(0); 99.72% 더 느리다. IE (v11)\n[0].concat(arr); // 3,604,226 ops/sec arr.unshift(0); 98.31% 더 느리다. Opera (v35.0.2066.68)\n[0].concat(arr); // 4,102,128 ops/sec arr.unshift(0); 97.44% 더 느리다. Safari (v9.0.3)\n[0].concat(arr); // 12,356,477 ops/sec arr.unshift(0); 15.17% 더 느리다. 최종 순위 1.[0].concat(arr); // 평균 6,032,573 ops/sec 2.arr.unshift(0); // 78.65% 더 느리다.\n배열의 중간에 추가 배열의 중간에 요소를 삽입하는 방법중 splice가 제일 쉽고 가장 효율적인 방법이다.\n1 2 var items = [\u0026#39;one\u0026#39;,\u0026#39;two\u0026#39;,\u0026#39;three\u0026#39;,\u0026#39;four\u0026#39;]; items.splice(itmes.length/2, 0,\u0026#39;hello\u0026#39;); 결론 배열의 맨 뒤에 추가할 때는 arr[arr.length]를 사용.\n배열의 맨 앞에 추가할 때는 concat을 사용. 배열 중간에 추가할 때는 splice을 사용.\n참고 insert-item-inside-an-array splice concat unshift push\nRelated Posts "}]