<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dev on Javascript Docs</title>
    <link>http://qweqwe9ab.github.io/categories/Dev/</link>
    <description>Recent content in Dev on Javascript Docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>qweqwe9ab@gmail.com (밤개발)</managingEditor>
    <webMaster>qweqwe9ab@gmail.com (밤개발)</webMaster>
    <lastBuildDate>Wed, 08 Dec 2021 14:47:11 +0900</lastBuildDate><atom:link href="http://qweqwe9ab.github.io/categories/Dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022년 계획</title>
      <link>http://qweqwe9ab.github.io/posts/etc/2022/</link>
      <pubDate>Wed, 08 Dec 2021 14:47:11 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/etc/2022/</guid>
      <description>인생의 전환점을 맞았던 21년은 새로운 인생을 위해서 조금 쉬어가는 시간을 보냈어
22년은 전환점을 지나서 새로운 시작이라고 생각하고, 새로운 계획을 세워보려해.
22년의 키워드는 지식 저장이야.
개발자는 공부를 많이 해야하는 직업이고, 새로운 지식을 늘려야 하는 직업이야
근데 나는 아직 공부와 지식을 저장하는 방법을 모른다고 생각해
그래서 22년도에는 공부하는 방법과 지식을 저장하는 방법에 대해서 생각하고, 노력하는 시간으로 정했어
공부와 지식을 저장하는 방법을 그냥 지식 저장법이라고 이야기 할게
우선 지금 생각하는 지식을 저장하는 방법은 블로그에 저장하는 방법과 메모장에 저장하는 거야</description>
    </item>
    
    <item>
      <title>2021 하반기 계획.</title>
      <link>http://qweqwe9ab.github.io/posts/etc/2021/</link>
      <pubDate>Thu, 23 Sep 2021 14:39:46 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/etc/2021/</guid>
      <description>안녕하세요 밤개발입니다.
아무도 들어오지 않는 블로그지만, 현재 제 상황을 제가 파악해야된다는 생각이 들어서 글을 적어봅니다.
현재 퇴직 후 이직 준비중인데, 아직 부족한게 많다고 느껴지네요
이제 경력이 주니어에서 시니어로 넘어가는 시점이기는 한데, 인터넷상의 다른 개발자 분들의 글과 이야기를 들어보면 한없이 작아집니다.
물론 제가 다른 분들에 비해 뛰어난 부분도 있다고 생각합니다. 하지만, 개발적인 기술적인 스킬이 아직 부족합니다.</description>
    </item>
    
    <item>
      <title>Javascript JSON Value를 기준으로 정렬하기</title>
      <link>http://qweqwe9ab.github.io/posts/js/jsonSort/</link>
      <pubDate>Wed, 04 Aug 2021 18:09:32 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/js/jsonSort/</guid>
      <description>JSON의 정렬 만약 유저의 이름을 key로 점수를 value로 JSON에 저장했다고 하고
1 2 3 4 5 const point = { &amp;#34;Jang&amp;#34;: 100, &amp;#34;Kim&amp;#34;: 20, &amp;#34;Lee&amp;#34;: 150 }; 유저를 점수순으로 리스트를 뽑아야된다면 아래와 같은 sort 함수를 만들어서 리스트를 생성한다.
1 2 3 4 5 6 7 const sort = (ob) =&amp;gt; { const arr = []; for(let i in ob) { arr.push([i, ob[i]]); } return arr.sort((a, b) =&amp;gt; a[1] - b[1]); } sort 함수는 매개변수로 들어온 object를 for문으로 돌면서 새로운 배열에 key와 value로 저장하고 arr.</description>
    </item>
    
    <item>
      <title>[JS Reference]Array.prototype</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.fill/</link>
      <pubDate>Tue, 20 Jul 2021 22:30:03 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.fill/</guid>
      <description> 설명 매개변수 ``optional
예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 </description>
    </item>
    
    <item>
      <title>[JS Reference]Set</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/set/</link>
      <pubDate>Tue, 20 Jul 2021 22:26:46 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/set/</guid>
      <description> 설명 매개변수 ``optional
예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 </description>
    </item>
    
    <item>
      <title>[LeetCode] 121. Best Time to Buy and Sell Stock [Easy]</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-121/</link>
      <pubDate>Thu, 08 Jul 2021 16:55:10 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-121/</guid>
      <description>#121. Best Time to Buy and Sell Stock
문제 주어진 배열은 일별 주식의 가격입니다. 배열의 인덱스는 날, 값은 가격입니다.
이 배열을 가지고 매매를 해서 최대의 수익을 반환하는 문제입니다. 설명 최대 수익을 저장하는 maxProfit와 최소 금액을 저장하는 min변수를 사용해서 최대 수익을 구하고, 그 값을 반환한다.
답 1 2 3 4 5 6 7 8 9 10 var maxProfit = function(prices) { let min = Number.MAX_SAFE_INTEGER; let maxProfit = 0; for (let i = 0; i &amp;lt; prices.</description>
    </item>
    
    <item>
      <title>[LeetCode] 238. Product of Array Except Self</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-238/</link>
      <pubDate>Thu, 08 Jul 2021 16:55:04 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-238/</guid>
      <description>#238. Product of Array Except Self
문제 숫자 배열 nums를 받아서 각 요소가 본인을 제외한 다른 요소 들의 곱으로 배열을 만들어 반환하는 문제이다.
EX) A,B,C,D를 숫자라고 생각하면 [A, B, C, D]의 결과는 [BCD, ACD, ABD, ABC]이다.
제약조건: O(n)
설명 우선 for문을 중복으로 돌면 해결될 것 같지만, O(n)으로 만들어야 되기 때문에 다른 방법을 생각해보자.
위에 문제에 설명 한 것 처럼 [A, B, C, D]가 주어지면 본인의 요소를 제외한 [BCD, ACD, ABD, ABC]를 반환해야 되는데.</description>
    </item>
    
    <item>
      <title>[LeetCode] 561. Array Partition I</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-561/</link>
      <pubDate>Thu, 08 Jul 2021 16:54:57 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-561/</guid>
      <description>#561. Array Partition I
문제 짝수개의 정수를 갖는 정수의 배열 nums가 주어진다. 요소들을 두개씩 짝을 지어서 그 짝들의 최솟값의 합이 최대인 값을 반환한다. 설명 우선, 2개씩 짝지어진 요소의 최솟값들의 합이 최대가 되기 위해서는 배열을 정렬을 해야됩니다.
배열을 sort() 를 사용해서 정렬하고, 작은수부터 2개씩 짝을지어 2개 중에 작은 값들을 더해서 총 합을 반환합니다.
그냥 sort() 를 사용하면 문자순으로 정렬되기 때문에 값을 비교해서 정렬하기 위해 nums.sort((a,b) =&amp;gt; a - b); 이렇게 작업합니다. 답 1 2 3 4 5 6 7 8 var arrayPairSum = function(nums) { nums.</description>
    </item>
    
    <item>
      <title>[LeetCode] 15. 3Sum [Medium]</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-15_/</link>
      <pubDate>Thu, 08 Jul 2021 16:54:51 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-15_/</guid>
      <description>#15. 3Sum
문제 설명 답 LeetCode Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
Example 1:
1 2 Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Example 2:
1 2 Input: nums = [] Output: [] Example 3:</description>
    </item>
    
    <item>
      <title>[LeetCode]20200708 Leetcode 42</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-42_/</link>
      <pubDate>Thu, 08 Jul 2021 16:54:45 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200708-leetcode-42_/</guid>
      <description>#
문제 설명 답 LeetCode </description>
    </item>
    
    <item>
      <title>[JS Reference]Array.prototype</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.push/</link>
      <pubDate>Thu, 08 Jul 2021 16:47:07 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.push/</guid>
      <description> 설명 매개변수 ``optional
예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 </description>
    </item>
    
    <item>
      <title>[JS Reference]Array.prototype</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.shift/</link>
      <pubDate>Thu, 08 Jul 2021 16:46:12 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.shift/</guid>
      <description> 설명 매개변수 ``optional
예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 </description>
    </item>
    
    <item>
      <title>[LeetCode] 5. Longest Palindromic Substring (Medium)</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-5_/</link>
      <pubDate>Thu, 08 Jul 2021 02:55:11 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-5_/</guid>
      <description>#5. Longest Palindromic Substring Medium
문제 주어진 문자열 s에서 가장 긴 회문을 반환하는 문제입니다.
답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var longestPalindrome = function(s) { let longest = &amp;#39;&amp;#39;; const findLongestPalindrome = (str, i, j) =&amp;gt; { while(i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; str.length &amp;amp;&amp;amp; str[i] === str[j]) { i -= 1; j += 1; } // slice the qualified substring from the second last iteration return str.</description>
    </item>
    
    <item>
      <title>[JS Reference] Array.prototype.sort()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.sort/</link>
      <pubDate>Thu, 08 Jul 2021 02:29:16 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.sort/</guid>
      <description>Array.prototype.sort() 설명 매개변수 ``optional
예제 1 2 console.log(); // output: 매개변수 사용법 1 2 console.log(); // output: 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[LeetCode] 49. Group Anagrams</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-49/</link>
      <pubDate>Thu, 08 Jul 2021 00:55:05 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-49/</guid>
      <description>#49. Group Anagrams
문제 단어의 배열을 받아서, 단어를 구성하는 알파벳의 순서가 다르더라고 같은 알파벳 들로 구성된 단어들을 묶어서 배열로 반환하는 문제입니다.
EX) &amp;rsquo;eat&amp;rsquo;, &amp;lsquo;ate&amp;rsquo;, &amp;rsquo;tea&amp;rsquo;는 같이 묶여서 반환 됩니다.
설명 우선, 단어에 문자 순서가 다른 모든 단어를 찾고 저장하기 위해서 기준으로 알파벳 순으로 정렬된 단어를 만든다. 예를 들어 eat, ate, tae에서는 알파벳 순서로 aet가 키가 되는 것이다. 이 키를 만들기 위해서 split()으로 단어를 쪼개고, sort() 를 사용해서 알파벳의 순서를 정렬하고, join() 을 이용해서 배열을 다시 단어로 만듭니다.</description>
    </item>
    
    <item>
      <title>[JS Reference] String.prototype.replace()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.replace/</link>
      <pubDate>Wed, 07 Jul 2021 16:12:26 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.replace/</guid>
      <description>String.prototype.replace() 설명 replace() 메서드는 패턴에 일치하는 부분이 교체된 새로운 문자열을 반환한다.
정규식, 문자열로 교체할 수 있다.
var newStr = str.replace(regexp|substr, newSubstr|function) 매개변수 regexppattern
정규식 객체 또는 리터럴
substrpattern
substr을 찾아서 새로운 값으로 변경한다. 변경 되어야 하는 string
newSubStrreplacement
변경될 string
functionreplacement
변경될 function
반환 새로운 문자열을 반환하고 기존 문자열은 변경되지 않는다.
예제 1 2 3 4 5 console.log(&amp;#39;hello world!&amp;#39;.replace(&amp;#39;l&amp;#39;, &amp;#39;a&amp;#39;)); // output: &amp;#34;healo world!&amp;#34; console.log(&amp;#39;Hello! world! 123&amp;#39;.replace(/[^a-z0-9]/gi,&amp;#34;&amp;#34;)); // output: &amp;#34;Helloworld123&amp;#34; 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[JS Reference] String.prototype.toLowerCase()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.toLowerCase/</link>
      <pubDate>Wed, 07 Jul 2021 16:04:27 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.toLowerCase/</guid>
      <description>String.prototype.toLowerCase() 설명 toLowerCase() 메서드는 문자열을 소문자로 변환해 반환한다.
예제 1 2 3 console.log(&amp;#39;Hello World!&amp;#39;.toLowerCase()); // output: hello world! 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[LeetCode] 819. Most Common Word</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-819/</link>
      <pubDate>Wed, 07 Jul 2021 15:54:59 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-819/</guid>
      <description>#819. Most Common Word
문제 주어진 문자열 paragraph에서 가장 많이 나온 단어를 반환하는 문제입니다. 단어는 대소문자를 구분하지 않으며 소문자로 리턴합니다.
설명 우선 paragraph는 대소문자를 구분하지 않지 때문에 str.toLowerCase() 를 이용해서 전부 소문자로 변경해줍니다.
그리고 str.replace() 를 통해 문자를 제외한 것들을 제거합니다. 문자만 남은 문자열에서 빈칸 &amp;rsquo; &amp;lsquo;을 기준으로 split()을 사용해서 자르고 단어의 배열로 만들어 줍니다. 이 단어의 배열을 돌면서 includes() 를 이용해서 banned에 포함되는 단어는 제외하하고, 단어를 키로, 나온 횟수를 값으로 가지는 data에 저장을하고, 이 data를 반복문으로 돌려 가장 많은 횟수를 가진 단어를 반환합니다.</description>
    </item>
    
    <item>
      <title>[LeetCode] 937. Reorder Data in Log Files</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-937/</link>
      <pubDate>Wed, 07 Jul 2021 15:54:52 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-937/</guid>
      <description>#937. Reorder Data in Log Files
문제 입력 받은 로그들을 문자로 이루어진 로그는 문자 알파벳순으로, 숫자 로그는 입력 순서로 정렬한다. 같은 문자의 문자로그는 식별자에 따라 정렬한다.
반환 순서는 정렬된 문자로그 + 입력 순서대로의 숫자로그 이다.
설명 우선 제가 생각한 방법은 입력받은로그를 문자로그, 숫자로그로 분류하고, 숫자로그는 입력순으로 저장한다.
문자로그는 앞에 식별자를 제외하고, 정렬작업을 진행한다.
그 후 정렬된 문자로그 + 숫자로그의 배열을 반환한다.
사용된 메소드 설명 split() join() shift() push() sort()
답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 var reorderLogFiles = function(logs) { const digit = []; // 숫자로그를 저장할 배열 const letter = []; // 문자로그를 저장할 배열 const result = []; // 최종으로 반환할 배열 for (let log of logs) { const arr = log.</description>
    </item>
    
    <item>
      <title>[LeetCode] 344. Reverse String</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-344/</link>
      <pubDate>Wed, 07 Jul 2021 15:54:45 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-344/</guid>
      <description>#344. Reverse String
문제 입력받은 문자 배열을 뒤집어라.
설명 배열의 순서를 뒤집어 주는 reverse() 메소드를 사용해서 배열의 순서를 뒤집습니다.
답 1 2 3 var reverseString = function(s) { return s.reverse(); }; LeetCode Write a function that reverses a string. The input string is given as an array of characters s.
Example 1:
1 2 Input: s = [&amp;#34;h&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;o&amp;#34;] Output: [&amp;#34;o&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;h&amp;#34;] Example 2:
1 2 Input: s = [&amp;#34;H&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;h&amp;#34;] Output: [&amp;#34;h&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;H&amp;#34;] Constraints:</description>
    </item>
    
    <item>
      <title>[LeetCode] 125. Valid Palindrome</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-125/</link>
      <pubDate>Wed, 07 Jul 2021 15:53:57 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200707-leetcode-125/</guid>
      <description>#125. Valid Palindrome
str.toLowerCase()
문제 입력받은 문자열에서 영문자와 숫자만 고려해서(대소문자 무시) 회문인지 확인해서 true/ false 반환.
설명 우선 회문은 뒤집어도 똑같은 문자열을 말합니다. 예를들어 기러기, 탄도유도탄, 다들 잠들다 같은 말입니다.
소문자로 만들기 제가 생각한 방법은 주어진 문자열 s를 str.toLowerCase() 를 이용해서 소문자로 만들어 줍니다.
숫자와 문자를 제외한 모든것 제거 그 후에 숫자와 문자를 제외한 모든것을 str.replace()를 이용해서 제거하고,
문자열 뒤집기 문자열을 뒤집어 주기 위해서 split() 으로 문자열을 쪼개서 배열로 만들고, reverse() 를 이용해서 배열의 순서를 뒤집고, join() 을 이용해서 배열을 문자열로 만들고 나면 뒤집어진 문자열이 생성됩니다.</description>
    </item>
    
    <item>
      <title>[JS Reference] String.prototype.indexOf()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.indexOf/</link>
      <pubDate>Wed, 07 Jul 2021 14:34:48 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.indexOf/</guid>
      <description>String.prototype.indexOf() 설명 str.indexOf(searchValue[, fromIndex]) 메서드는 호출한 String에서 주어진 값과 일치하는 첫 번째 인덱스를 반환한다. 일치하는 값이 없으면 -1을 반환한다.
매개변수 searchValue
주어진 String에서 찾을 값, searchValue값이 없다면 문자열 undefined를 찾으려는 것으로 간주한다.
fromIndexoptional 문자열에서 찾기 시작하는 위치 인덱스 값.
반환값 첫 번째 인덱스를 반환하고, 찾을 수 없다면 -1을 반환한다.
예제 1 2 3 4 5 6 7 8 console.log(&amp;#39;Hello World!&amp;#39;.indexOf(&amp;#39;llo&amp;#39;)); // output: 2 console.log(&amp;#39;Hello World!&amp;#39;.indexOf(&amp;#39; &amp;#39;)); // output: 5 console.</description>
    </item>
    
    <item>
      <title>[JS Reference] Array.prototype.includes()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.includes/</link>
      <pubDate>Wed, 07 Jul 2021 14:34:40 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.includes/</guid>
      <description>Array.prototype.includes() 설명 arr.includes(valueToFind[, fromIndex]) 메서드는 배열이 특정 요소를 포함하고 있는지 확인한다.
반환값은 true / false
매개변수 valueToFind
찾을 요소, 대소문자 구분
fromIndexoptional
찾기 시작할 위치 인덱스 기본값은 0이다.
예제 1 2 3 4 5 6 7 8 console.log([&amp;#39;H&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;Apple&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;Facebook&amp;#39;].includes(&amp;#39;A&amp;#39;)); // output: true console.log([&amp;#39;H&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;Apple&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;Facebook&amp;#39;].includes(&amp;#39;C&amp;#39;)); // output: false console.log([&amp;#39;H&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;Apple&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;Facebook&amp;#39;].includes(&amp;#39;Apple&amp;#39;)); // output: true console.log([&amp;#39;H&amp;#39;, &amp;#39;L&amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;Apple&amp;#39;, &amp;#39;D&amp;#39;, &amp;#39;Facebook&amp;#39;].</description>
    </item>
    
    <item>
      <title>[LeetCode] 14. Longest Common Prefix</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-14/</link>
      <pubDate>Wed, 07 Jul 2021 13:27:57 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-14/</guid>
      <description>#14. Longest Common Prefix
문제 주어진 문자열의 배열에서 가장 긴 접두사를 찾는 문제.
설명 처음에는 접두사라는게 뭔지몰라서 가장긴 공통된 문자열을 찾는 줄 알고, 열심히 코드를 만들었습니다. 근데 Submit을 눌러보니 계속 틀렸다고 나와서 접두사를 검색해보고 다시 코드를 만들었습니다. 제가 실수로 만든 가장 긴 공통된 문자열을 찾는 코드는 아래 따로 설명하겠습니다.
자세한 설명은 코드에 주석으로 적겠지만, 간단하게 말하면 입력받은 모든 문자열을 돌면서 가장긴 접두사를 찾습니다. indexOf() 를 사용해서 indexOf() 가 0 을 반환하는지 확인해서 접두사인지 확인할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[LeetCode] 13. Roman to Integer</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-13/</link>
      <pubDate>Wed, 07 Jul 2021 02:26:12 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-13/</guid>
      <description>#13. Roman to Integer
문제 로마 숫자는 일곱 가지 기호로 표시됩니다 : I, V, X, L, C, D와 M. 입력받은 로마 숫자를 정수로 변환해서 리턴하는 문제입니다.
답 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var romanToInt = function(s) { const romanNumerals = { &amp;#39;I&amp;#39;: 1, &amp;#39;V&amp;#39;: 5, &amp;#39;X&amp;#39;: 10, &amp;#39;L&amp;#39;: 50, &amp;#39;C&amp;#39;: 100, &amp;#39;D&amp;#39;: 500, &amp;#39;M&amp;#39;: 1000, }; let prev = 0; let result = 0; for(let i = 0; i&amp;lt;s.</description>
    </item>
    
    <item>
      <title>[JS Reference] parseInt()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/parseInt/</link>
      <pubDate>Tue, 06 Jul 2021 14:32:22 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/parseInt/</guid>
      <description>parseInt(string, radix) 설명 매개변수 string는 문자열이 아니라면 문자열로 변환하고 선행 공백은 무시합니다.
radixoptional 2와 36 사이의 진수(default가 10이 아니다.)
string 이 &amp;ldquo;0x&amp;rdquo; 나 &amp;ldquo;0X&amp;quot;로 시작한다면, radix 는 16(16진) string 이 &amp;ldquo;0&amp;quot;으로 시작한다면, radix 는 8(8진)이거나, 10(십진)입니다. string 이 다른 값으로 시작 된다면, radix 는 10(십진)입니다.
반환값 주어진 string으로부터 분석한 radix진수의 정수를 반환합니다.
숫자로 시작하고, 중간에 숫자가 아닌 문자가 나오는 경우는 문자를 무시하고 앞까지의 숫자를 리턴한다.
NaN을 반환하는 경우: radix가 2보다 작거나 36보다 큰 경우 첫번째 non-whitespace 문자가 숫자로 변환되지 않는 경우</description>
    </item>
    
    <item>
      <title>[JS Reference] String.prototype.toString()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.toString/</link>
      <pubDate>Tue, 06 Jul 2021 14:25:08 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.toString/</guid>
      <description>String.prototype.toString() 설명 toString() 메소드는 지정된 객체를 나타내는 문자열을 반환합니다.
예제 1 2 3 4 5 6 7 8 console.log(&amp;#39;asd&amp;#39;.toString()); // output: &amp;#39;asd&amp;#39; console.log(&amp;#39;2020&amp;#39;.toString()); // output: &amp;#39;2020&amp;#39; console.log(&amp;#39;2020Hello&amp;#39;.toString()); // output: &amp;#39;2020Hello&amp;#39; 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[JS Reference] Math.sign()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Math.sign/</link>
      <pubDate>Tue, 06 Jul 2021 14:24:27 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Math.sign/</guid>
      <description>Math.sign() 설명 sign(x)는 매개변수를 숫자로 변경하고 x의 부호를 반환합니다.
양수, 음수, 양수인 영 또는 음수인 영을 구분해서 1, -1, 0, -0을 반환합니다. 그게 아니라면 NaN을 반환합니다.
예제 반환값이 1인 경우 1 2 3 4 5 6 7 8 9 10 11 console.log(Math.sign(10)); // output: 1 console.log(Math.sign(&amp;#34;20&amp;#34;)); // output: 1 console.log(Math.sign(24120)); // output: 1 console.log(Math.sign(1)); // output: 1 반환값이 -1인 경우 1 2 3 4 5 6 7 8 9 10 11 console.</description>
    </item>
    
    <item>
      <title>[JS Reference] Math.abs()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Math.abs/</link>
      <pubDate>Tue, 06 Jul 2021 14:04:09 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Math.abs/</guid>
      <description>Math.abs() 설명 Math.abs(v)는 v의 절대값을 반환합니다.
예제 1 2 3 4 5 6 7 8 9 10 11 12 13 console.log(Math.abs(10)); // 결과: 10 console.log(Math.abs(-10)); // 결과: 10 console.log(Math.abs(&amp;#34;10&amp;#34;)); // 결과: 10 console.log(Math.abs(&amp;#34;-10&amp;#34;)); // 결과: 10 console.log(Math.abs(&amp;#34;-10a&amp;#34;)); // 결과: NaN 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[JS Reference] String.prototype.split()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.split/</link>
      <pubDate>Tue, 06 Jul 2021 14:03:50 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/String.prototype.split/</guid>
      <description>String.prototype.split([separator[, limit]]) 설명 split() 메서드 string 객체를 구분자(separator)을 이용해서 여러개의 문자열로 나눈 배열을 반환합니다.
매개변수 separatoroptional
원본 문자열을 나눌 구분자 문자열이나 정규표현식을 사용할 수 있다.
limitoptional
끊어진 문자열의 최대 개수
예제 빈 문자열인 경우 1 2 3 const str = &amp;#39;&amp;#39;; console.log(str.split()); // output: [&amp;#34;&amp;#34;] 매개변수 사용법 1 2 3 const str = &amp;#39;Hello World&amp;#39;; console.log(str.split(&amp;#39; &amp;#39;, 1)); // output: [&amp;#34;Hello&amp;#34;] 참고 사이트 mozilla</description>
    </item>
    
    <item>
      <title>[JS Reference] Array.prototype.join()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.join/</link>
      <pubDate>Tue, 06 Jul 2021 14:03:42 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.join/</guid>
      <description>Array.prototype.join([separator]) 설명 join()은 배열의 모든 요소를 연결해서 하나의 문자열로 만들어 반환합니다.
배열을 변경하지 않고 반환만 합니다.
매개변수 separator optional
배열의 각 요소를 구분 문자열을 지정합니다.
default: ,로 연결
예제 separator값이 default인 경우 1 2 3 4 5 6 7 8 const arr = [&amp;#39;apple&amp;#39;, &amp;#39;google&amp;#39;, &amp;#39;facebook&amp;#39;]; console.log(arr.join()); // output: &amp;#34;apple,google,facebook&amp;#34; console.log(arr); // output: [&amp;#39;apple&amp;#39;, &amp;#39;google&amp;#39;, &amp;#39;facebook&amp;#39;] 매개변수 사용법 sparator값이 &amp;lsquo;&amp;lsquo;인 경우 1 2 console.log(arr.join(&amp;#39;&amp;#39;)); // output: &amp;#34;applegooglefacebook&amp;#34; sparator값이 &amp;rsquo; &amp;lsquo;인 경우 1 2 console.</description>
    </item>
    
    <item>
      <title>[JS Reference] Array.prototype.reverse()</title>
      <link>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.reverse/</link>
      <pubDate>Tue, 06 Jul 2021 14:03:17 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/jsReference/Array.prototype.reverse/</guid>
      <description> Array.prototype.reverse() 설명 reverse()는 배열의 순서를 뒤집고 뒤집힌 배열을 반환합니다.
원본을 뒤집고 참조를 반환합니다.
예제 1 2 3 4 5 6 7 8 9 10 11 const arr = [1,2,3,4,5]; console.log(arr); // output: [1, 2, 3, 4, 5] const reverse = arr.reverse(); console.log(reverse); // output: [5, 4, 3, 2, 1] console.log(arr); // output: [5, 4, 3, 2, 1] 참고 사이트 </description>
    </item>
    
    <item>
      <title>[LeetCode] 20. Valid Parentheses</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-20_/</link>
      <pubDate>Tue, 06 Jul 2021 13:28:00 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200706-leetcode-20_/</guid>
      <description>#20. Valid Parentheses
문제 답 설명 LeetCode </description>
    </item>
    
    <item>
      <title>[LeetCode] 9. Palindrome Number</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200705-LeetCode-9/</link>
      <pubDate>Mon, 05 Jul 2021 17:35:35 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200705-LeetCode-9/</guid>
      <description>9. Palindrome Number 문제 우선 Palindrome이 뭔지 몰라서 사전에 검색을 해보니
회문(回文: madam이나 nurses run처럼 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 단어나 구)
이라고 나옵니다. 단어를 그대로 읽나 거꾸로 뒤집어 읽나 똑같은 단어를 말한다고 합니다. 예를들어 기러기는 그대로 읽어도 기러기, 거꾸로 읽어도 기러기가되니까 회문이 맞습니다!
하지만 여기서는 문자 회문? 이니까 숫자로 값을 입력할 것 입니다. 예를들어 123이 들어오면 false를 반환하고 232가 들어오면 true를 반환합니다.
답 1 2 3 4 5 var isPalindrome = function(x) { if (x &amp;lt; 0) return false; const palindrome = parseInt(x.</description>
    </item>
    
    <item>
      <title>[LeetCode] 7. Reverse Integer</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-7/</link>
      <pubDate>Mon, 05 Jul 2021 17:12:12 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-7/</guid>
      <description>#7. Reverse Integer
문제 32비트 숫자를 입력받고 숫자를 뒤집에서 반환한다. 음수이면 -를 붙혀서 반환한다.
설명 우선, 제가 생각한 방법은 입력받은 숫자를 양수/음수 구분없게 절대값으로 만들고, 숫자를 뒤집고, 입력받은 숫자였으면 -를 붙혀서 반환하는 방법을 생각했다. Math.abs() 를 이용해서 절대값을 만들고, toString() 을 이용해서 숫자를 문자로 바꾼다음,
split() 으로 문자를 쪼개서 배열로 만들고, reverse() 를 이용해서 배열의 순서를 뒤집고, join() 을 이용해서 배열을 문자열로 만들고 Math.sign() 을 이용해서 x의 부호를 가져와 숫자의 부호를 넣어준다.</description>
    </item>
    
    <item>
      <title>[LeetCode] 1. Two Sum</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-1/</link>
      <pubDate>Mon, 05 Jul 2021 15:38:55 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-1/</guid>
      <description>1. Two Sum 문제 숫자로 이루어진 배열과, 숫자로된 타겟을 입력받아서 배열에서 타켓을 만들 수 있는 숫자의 인덱스를 반환.
만약에 배열 [1, 3, 6, 7]과 타겟 8을 입력 받는다면 [0, 3]를 반환한다
답 1 2 3 4 5 6 7 var twoSum = function(nums, target) { for (let i = 0; i &amp;lt; nums.length; i++) { const test = target - nums[i]; const index = nums.indexOf(test); if (index != -1 &amp;amp;&amp;amp; index !</description>
    </item>
    
    <item>
      <title>Leetcode 계획</title>
      <link>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-start/</link>
      <pubDate>Mon, 05 Jul 2021 14:39:17 +0900</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/leetcode/20200705-leetcode-start/</guid>
      <description>Leetcode 시작. 언제든지 인터뷰를 볼 수 있도록 계속 코딩테스트를 준비할 예정입니다.
물론 경력직의 이직에서 코딩테스트가 가장 중요한 것은 아니겠지만, 나중에 어떤 기회가 올 수 있을지 모르기 때문에! 열심히 준비해 보도록 하겠습니다.
우선, Leetcode는 Easy 단계를 하나씩 순서대로 풀어보겠습니다.
매일 한 문제씩 푸는 것은 목표로 달려보겠습니다!</description>
    </item>
    
    <item>
      <title>[javascript] 하노이 탑 (Hanoi Tower)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190120-Hanoi/</link>
      <pubDate>Sun, 20 Jan 2019 18:29:32 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190120-Hanoi/</guid>
      <description>하노이 탑 하노이 탑은 다음과 같은 조건을 가지고 있다.
한번에 하나의 원판만 이동 맨위에 있는 원판만 이동 가능 작은 원판 위에 큰 원판을 올리는 것은 불가능 중간의 막대는 임시적으로 이용 가능 n-1개를 A에서 B로 이동하고, n개를 A에서 C로 이동한다. 그리고 n-1개를 B에서 C로 이동한다.
1 2 3 4 5 6 7 8 9 10 let hanoi = (n, from, temp, to) =&amp;gt; { if(n===1) console.log(`${n}을 ${from}에서 ${to}로 이동`); else { hanoi(n-1, from, to, temp); console.</description>
    </item>
    
    <item>
      <title>[javascript] 피보나치 (Fibonacci)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190120-Fibonacci/</link>
      <pubDate>Sun, 20 Jan 2019 17:53:44 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190120-Fibonacci/</guid>
      <description>피보나치 수열 0, 1, 1, 2, 3, 5, 8, 13, 21.... 피보나치는 0번째는 0, 첫 번째는 1 그 이후로는 이전 두개의 수를 더한 값을 갖는 수열이다.
F(0) = 0, F(1) = 1, F(n) = F(n-2) + F(n-1)
1 2 3 4 5 6 7 8 9 10 11 let fib = (num) =&amp;gt; { if(num &amp;lt;= 1) return num; return fib(num-1) + fib(num-2); } console.log(fib(1)) console.log(fib(2)) console.log(fib(3)) console.log(fib(4)) console.log(fib(5)) console.</description>
    </item>
    
    <item>
      <title>동기와 비동기</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190119-Sync-VS-Async/</link>
      <pubDate>Sat, 19 Jan 2019 17:42:36 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190119-Sync-VS-Async/</guid>
      <description>설명 동기 여러작업을 진행 할때 하나의 작업이 끝날때 까지 기다렸다가 다음 작업을 진행하는 것.
비동기 여러작업을 진행 할때 하나의 작업을 실행하고 다음 작업으로 넘어간다. 이전에 실행한 작업은 작업이 끝나고 callback을 넘긴다.
비유 간단하게 설명하면 동기는 카페에서 손님에게 주문을 받고 커피를 만들어서 전달하고 다음 손님으로 넘어가는 것 이고 비동기는 카페에서 손님에게 주문을 받고 진동벨을 준 다음 다음 손님의 주문으로 넘어가고, 손님의 커피가 제조가 완료되면 진동벨(callback)을 울려 해당 손님에게 전달한다.
코드 동기 코드</description>
    </item>
    
    <item>
      <title>프로세스(Process) vs 쓰레드(Thread)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190119-Process-VS-Thread/</link>
      <pubDate>Sat, 19 Jan 2019 17:09:10 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190119-Process-VS-Thread/</guid>
      <description>프로세스 프로세스는 실행중인 프로그램이다. 디스크로에서 메모리로 적재되어 CPU의 할당을 받을 수 있다. 쓰레드 프로세스의 실행단위 한 프로세스 내에서 동작되는 여러 실행으로 프로세스내의 주소공간이나 자원을 공유한다. 멀티 쓰레드 메모리 공간과 시스템 자원 소모가 줄어들게 된다. 쓰레드 간의 공유된 자원을 사용해 쓰레드간의 통신이 간단하고 빠르다 멀티 쓰레드 문제점 자원을 공유하기 때문에 신경을 써야한다. 동기화 작업으로 인해 성능이 저하될 수 있다. 요약 프로세스는 운영체제로 부터 자원을 할당받는 자원단위(실행중인 프로그램) 쓰레드는 프로세스가 할당 받은 자원을 이용하는 실행 단위()</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 스택으로 큐 구현 javascript</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Queue-Using-Stacks/</link>
      <pubDate>Fri, 18 Jan 2019 15:46:22 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Queue-Using-Stacks/</guid>
      <description>오늘은 스택으로 큐를 구현하는 문제를 살펴보겠습니다. 스택은 LIFO - Last In First Out 방식이다. 간단하게 설명하면 책상 위에 책을 하나씩 쌓아두고 위에서부터 하나씩 집어서 읽는 것이다.
나중에 쌓은(제일 위에 있는) 책을 먼저 집어서 읽는 방식 큐는 FIFO - First In First Out 방식이다. 간단하게 설명하면 카페에서 한 줄로 서서 주문을 하는 것이다.
제일 먼저 온 사람이 먼저 계산하는 방식 스택과 큐에 대한 설명과 코드는 이 블로그의 글을 참조하고, 오늘은 스택으로 큐를 구현해 보겠습니다.</description>
    </item>
    
    <item>
      <title>[Codewars] 주사위 게임 &#34;Greed is Good&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Greed-is-Good/</link>
      <pubDate>Fri, 18 Jan 2019 15:35:22 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Greed-is-Good/</guid>
      <description>설명 문제 주사위(1-6)를 굴려서 나온 수에 따른 점수를 매겨라.
1 2 3 4 5 6 7 8 Three 1&amp;#39;s =&amp;gt; 1000 points Three 6&amp;#39;s =&amp;gt; 600 points Three 5&amp;#39;s =&amp;gt; 500 points Three 4&amp;#39;s =&amp;gt; 400 points Three 3&amp;#39;s =&amp;gt; 300 points Three 2&amp;#39;s =&amp;gt; 200 points One 1 =&amp;gt; 100 points One 5 =&amp;gt; 50 point 1 2 3 4 5 Throw Score --------- ------------------ 5 1 3 4 1 50 + 2 * 100 = 250 1 1 1 3 1 1000 + 100 = 1100 2 4 4 5 4 400 + 50 = 450 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function score( dice ) { let scores = {}; let returnValue = 0; for(let i in dice) { if(scores[dice[i]]) { scores[dice[i]]++; }else { scores[dice[i]] = 1; } } for(let i in scores) { let s = scores[i]; if(i == 1 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 1000; s -=3;} if(i == 2 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 200; s -=3;} if(i == 3 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 300; s -=3;} if(i == 4 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 400; s -=3;} if(i == 5 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 500; s -=3;} if(i == 6 &amp;amp;&amp;amp; s &amp;gt;= 3) {returnValue += 600; s -=3;} if(i == 1) returnValue += s * 100; if(i == 5) returnValue += s * 50; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 function score( dice ) { var dc = [0,0,0,0,0,0]; var tdr = [1000,200,300,400,500,600]; var sdr = [100,0,0,0,50,0]; dice.</description>
    </item>
    
    <item>
      <title>[Codewars] 다이아몬드 모양 출력 &#34;Codewars_Give_me_a_Diamond&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Give-me-a-Diamond/</link>
      <pubDate>Fri, 18 Jan 2019 04:57:35 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Give-me-a-Diamond/</guid>
      <description>설명 문제 n을 입력받아서 다이아몬드 모양을 출력하는 문제
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function diamond(n){ if(n &amp;lt; 0 || n%2 ==0) return null; let returnValue = &amp;#39;&amp;#39;; for(let i = 1;i&amp;lt;=n;i+=2) { for(let j=0;j&amp;lt;(n-i)/2;j++) returnValue += &amp;#39; &amp;#39;; for(let j=0;j&amp;lt;i;j++)returnValue += &amp;#39;*&amp;#39;; returnValue +=&amp;#39;\n&amp;#39;; } for(let i = n-2; i&amp;gt;0; i-=2) { for(let j=0;j&amp;lt;(n-i)/2;j++) returnValue += &amp;#39; &amp;#39;; for(let j=0;j&amp;lt;i;j++)returnValue += &amp;#39;*&amp;#39;; returnValue +=&amp;#39;\n&amp;#39;; } return returnValue; } 다른 답 1 2 3 4 5 6 7 8 9 10 11 12 function diamond(n){ if( n%2==0 || n&amp;lt;1 ) return null var x=0, add, diam = line(x,n); while( (x+=2) &amp;lt; n ){ add = line(x/2,n-x); diam = add+diam+add; } return diam; } function repeat(str,x){return Array(x+1).</description>
    </item>
    
    <item>
      <title>[Codewars] 후위표기법 문제 &#34;Reverse polish notation calculator&#34;</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Reverse-Polish-Notation-Calculator/</link>
      <pubDate>Fri, 18 Jan 2019 04:24:18 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190118-Codewars-Reverse-Polish-Notation-Calculator/</guid>
      <description>우리가 알고있는 수식은 5 + ((1 + 2) * 4) - 3 같은 식이다. 하지만 후위표기법에서는 5 1 2 + 4 * + 3 -이런식으로 표현한다.
문제 후위표기법으로 제공되는 식을 풀어 답을 리턴하시오.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function calc(expr) { let exp = expr.</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 연결리스트(linked list)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Linked-List/</link>
      <pubDate>Thu, 17 Jan 2019 17:40:16 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Linked-List/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const linkedListNode = class LinkedListNode { constructor(value, next = null) { this.</description>
    </item>
    
    <item>
      <title>REST API</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Rest-API/</link>
      <pubDate>Thu, 17 Jan 2019 17:12:02 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Rest-API/</guid>
      <description>REST API REST (Representational State Transfer) web의 장점을 최대한 활용할 수 있는 아키텍쳐 HTTP 메서드 메서드 의미 멱등성 POST Create x GET Select O PUT Update O DELETE Delete O 멱등성 : 연산을 여러번해도 달라지지 않는것. REST는 상태 없이 API를 수행한다 그래서 여러 API를 호출하다 실패시 복구해야 하는데 멱등성 메서드는 복구가 필요없다. REST는 리소스 지향으로 모든 것은 명사로 표현한다. 각 세부 리소스에는 ID를 추가한다. REST API의 특성 유니폼 인터페이스 : 표준만 따르면 어떤 기술이라도 사용가능 무상태성 / 스테이트리스 : 서버는 상태를 저장하지 않으므로 각 API 서버는 들어오는 요청만 수행, 구현이 단순 캐슁가능 : HTTP에서 제공하는 캐슁 가능 자체 표현구조 : REST API만 보고 쉽게 이해할 수 있다.</description>
    </item>
    
    <item>
      <title>http와 https</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-http-vs-https/</link>
      <pubDate>Thu, 17 Jan 2019 16:15:54 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-http-vs-https/</guid>
      <description> Related Posts http (Hyper Text Transfer Protocol) Client와 Server가 메세지를 주고 받는 통신 규약 http://로 시작 메세지를 암호화 하지 않음 https (Hyper Text Transfer Protocol Secure Socket Layer) Client와 Server가 메세지를 주고 받는 통신 규약 https://로 시작 메세지를 암호화함 공개키, 개인키 암호화 SSL 인증서 구입 비용과 갱신 비용이 비싸다 암호화로 속도가 느리다 Related Posts </description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 큐(Queue)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Queue/</link>
      <pubDate>Wed, 16 Jan 2019 17:40:01 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Queue/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function createQueue() { const queue = []; return { enqueue(item) { queue.unshift(item); }, dequeue() { return queue.pop(); }, peek() { return queue[queue.length -1]; }, get length() { return queue.length; }, isEmpty() { return queue.length === 0; } } } const q = createQueue(); q.</description>
    </item>
    
    <item>
      <title>[자료구조][자바스크립트] 스택(Stack)</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Stack/</link>
      <pubDate>Wed, 16 Jan 2019 17:39:50 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190117-Javascript-Stack/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function createStack() { const stack = []; return { push(item) { stack.push(item); }, pop() { return stack.pop(); }, peek() { return stack[stack.length - 1]; }, get length() { return stack.length; }, isEmpty() { return stack.length === 0; } } } const s = createStack(); s.</description>
    </item>
    
    <item>
      <title>[jstips] 중첩된 조건문 개선 if, switch</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190114-improve-nested-conditionals/</link>
      <pubDate>Mon, 14 Jan 2019 18:04:48 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190114-improve-nested-conditionals/</guid>
      <description>중첩된 조건문 개선 jstips에서 javascript를 사용할 때 중첩된 if문을 조금 더 깔끔하고 효율적으로 만들 수 있을지에 대해서 읽었습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (color) { if (color === &amp;#39;black&amp;#39;) { printBlackBackground(); } else if (color === &amp;#39;red&amp;#39;) { printRedBackground(); } else if (color === &amp;#39;blue&amp;#39;) { printBlueBackground(); } else if (color === &amp;#39;green&amp;#39;) { printGreenBackground(); } else { printYellowBackground(); } } 우선 중첩된 if문을 개선하는 방법 중에 하나는 switch문을 사용하는 것입니다.</description>
    </item>
    
    <item>
      <title>[jstips] 배열에 요소 추가하기 push(),concat(),unshift()</title>
      <link>http://qweqwe9ab.github.io/posts/old/20190114-insert-item-inside-an-array/</link>
      <pubDate>Mon, 14 Jan 2019 18:01:39 +0000</pubDate>
      <author>qweqwe9ab@gmail.com (밤개발)</author>
      <guid>http://qweqwe9ab.github.io/posts/old/20190114-insert-item-inside-an-array/</guid>
      <description>오늘은 jstips에서 첫 번째 팁인 배열에 요소 추가하는 방법을 공부해보겠습니다.
저도 개발을 하다 보면 배열에 요소를 추가하는 작업을 많이 하게 되는데, push()를 사용해서 배열의 끝에 요소를 넣고, unshift를 사용해서 배열의 시작 부분에 요소를 넣고, splice를 사용해서 배열의 중간에 요소를 넣는 것은 알고 그렇게 작업을 했었습니다. 근데 jstips에서 글을 읽으면서 속도와 성능을 생각하면서 작업을 하는 것도 필요할 것 같다는 생각이 들었습니다.
귀찮은 분들을 위해 맨 아래에 결론을 적어놨습니다!
배열의 끝부분에 추가 배열의 끝에 요소를 추가하는 방법 중 제일 쉬운 방법은 push()를 사용하는 것인데, 다른 방법들도 있다.</description>
    </item>
    
  </channel>
</rss>
